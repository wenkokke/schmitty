<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>SMT.Backend.Base</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Keyword">module</a> <a id="8" href="SMT.Backend.Base.html" class="Module">SMT.Backend.Base</a> <a id="25" class="Keyword">where</a>

<a id="32" class="Keyword">open</a> <a id="37" class="Keyword">import</a> <a id="44" href="Data.List.html" class="Module">Data.List</a> <a id="54" class="Symbol">as</a> <a id="57" class="Module">List</a> <a id="62" class="Keyword">using</a> <a id="68" class="Symbol">(</a><a id="69" href="Agda.Builtin.List.html#148" class="Datatype">List</a><a id="73" class="Symbol">;</a> <a id="75" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">_∷_</a><a id="78" class="Symbol">;</a> <a id="80" href="Data.List.Base.html#9981" class="InductiveConstructor">[]</a><a id="82" class="Symbol">)</a>
<a id="84" class="Keyword">open</a> <a id="89" class="Keyword">import</a> <a id="96" href="Data.List.Relation.Unary.All.html" class="Module">Data.List.Relation.Unary.All</a> <a id="125" class="Symbol">as</a> <a id="128" class="Module">All</a> <a id="132" class="Keyword">using</a> <a id="138" class="Symbol">(</a><a id="139" href="Data.List.Relation.Unary.All.html#1397" class="Datatype">All</a><a id="142" class="Symbol">;</a> <a id="144" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">_∷_</a><a id="147" class="Symbol">;</a> <a id="149" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a><a id="151" class="Symbol">)</a>
<a id="153" class="Keyword">open</a> <a id="158" class="Keyword">import</a> <a id="165" href="Data.Product.html" class="Module">Data.Product</a> <a id="178" class="Keyword">using</a> <a id="184" class="Symbol">(</a><a id="185" href="Data.Product.html#1167" class="Function Operator">_×_</a><a id="188" class="Symbol">;</a> <a id="190" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a><a id="193" class="Symbol">;</a> <a id="195" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a><a id="200" class="Symbol">;</a> <a id="202" href="Agda.Builtin.Sigma.html#264" class="Field">proj₂</a><a id="207" class="Symbol">)</a>
<a id="209" class="Keyword">open</a> <a id="214" class="Keyword">import</a> <a id="221" href="Data.String.html" class="Module">Data.String</a> <a id="233" class="Symbol">as</a> <a id="236" class="Module">String</a> <a id="243" class="Keyword">using</a> <a id="249" class="Symbol">(</a><a id="250" href="Agda.Builtin.String.html#336" class="Postulate">String</a><a id="256" class="Symbol">)</a>
<a id="258" class="Keyword">open</a> <a id="263" class="Keyword">import</a> <a id="270" href="Data.Unit.html" class="Module">Data.Unit</a> <a id="280" class="Keyword">using</a> <a id="286" class="Symbol">(</a><a id="287" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a><a id="288" class="Symbol">)</a>
<a id="290" class="Keyword">open</a> <a id="295" class="Keyword">import</a> <a id="302" href="Function.html" class="Module">Function</a> <a id="311" class="Keyword">using</a> <a id="317" class="Symbol">(</a><a id="318" href="Function.Base.html#4121" class="Function Operator">case_of_</a><a id="326" class="Symbol">;</a> <a id="328" href="Function.Base.html#636" class="Function">const</a><a id="333" class="Symbol">;</a> <a id="335" href="Function.Base.html#1919" class="Function Operator">_$_</a><a id="338" class="Symbol">;</a> <a id="340" href="Function.Base.html#1031" class="Function Operator">_∘_</a><a id="343" class="Symbol">;</a> <a id="345" href="Function.Base.html#1554" class="Function">flip</a><a id="349" class="Symbol">)</a>
<a id="351" class="Keyword">open</a> <a id="356" class="Keyword">import</a> <a id="363" href="Reflection.html" class="Module">Reflection</a> <a id="374" class="Symbol">as</a> <a id="377" class="Module">Rfl</a> <a id="381" class="Keyword">using</a> <a id="387" class="Symbol">(</a><a id="388" href="Agda.Builtin.Reflection.html#7543" class="Postulate">return</a><a id="394" class="Symbol">;</a> <a id="396" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">_&gt;&gt;=_</a><a id="401" class="Symbol">;</a> <a id="403" href="Reflection.TypeChecking.Monad.Syntax.html#752" class="Function Operator">_&gt;&gt;_</a><a id="407" class="Symbol">)</a>
<a id="409" class="Keyword">open</a> <a id="414" class="Keyword">import</a> <a id="421" href="SMT.Theory.html" class="Module">SMT.Theory</a>


<a id="434" class="Keyword">postulate</a>
  <a id="because"></a><a id="446" href="SMT.Backend.Base.html#446" class="Postulate">because</a> <a id="454" class="Symbol">:</a> <a id="456" class="Symbol">∀</a> <a id="458" class="Symbol">{</a><a id="459" href="SMT.Backend.Base.html#459" class="Bound">a</a><a id="460" class="Symbol">}</a> <a id="462" class="Symbol">(</a><a id="463" href="SMT.Backend.Base.html#463" class="Bound">solver</a> <a id="470" class="Symbol">:</a> <a id="472" href="Agda.Builtin.String.html#336" class="Postulate">String</a><a id="478" class="Symbol">)</a> <a id="480" class="Symbol">(</a><a id="481" href="SMT.Backend.Base.html#481" class="Bound">A</a> <a id="483" class="Symbol">:</a> <a id="485" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="489" href="SMT.Backend.Base.html#459" class="Bound">a</a><a id="490" class="Symbol">)</a> <a id="492" class="Symbol">→</a> <a id="494" href="SMT.Backend.Base.html#481" class="Bound">A</a>

<a id="`because"></a><a id="497" href="SMT.Backend.Base.html#497" class="Function">`because</a> <a id="506" class="Symbol">:</a> <a id="508" class="Symbol">(</a><a id="509" href="SMT.Backend.Base.html#509" class="Bound">solver</a> <a id="516" class="Symbol">:</a> <a id="518" href="Agda.Builtin.String.html#336" class="Postulate">String</a><a id="524" class="Symbol">)</a> <a id="526" class="Symbol">(</a><a id="527" href="SMT.Backend.Base.html#527" class="Bound">A</a> <a id="529" class="Symbol">:</a> <a id="531" href="Agda.Builtin.Reflection.html#4317" class="Function">Rfl.Type</a><a id="539" class="Symbol">)</a> <a id="541" class="Symbol">→</a> <a id="543" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Rfl.Term</a>
<a id="552" href="SMT.Backend.Base.html#497" class="Function">`because</a> <a id="561" href="SMT.Backend.Base.html#561" class="Bound">solver</a> <a id="568" href="SMT.Backend.Base.html#568" class="Bound">A</a> <a id="570" class="Symbol">=</a> <a id="572" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">Rfl.def</a> <a id="580" class="Symbol">(</a><a id="581" class="Keyword">quote</a> <a id="587" href="SMT.Backend.Base.html#446" class="Postulate">because</a><a id="594" class="Symbol">)</a> <a id="596" class="Symbol">(</a><a id="597" href="Reflection.Argument.html#1071" class="InductiveConstructor">Rfl.vArg</a> <a id="606" class="Symbol">(</a><a id="607" href="Agda.Builtin.Reflection.html#4719" class="InductiveConstructor">Rfl.lit</a> <a id="615" class="Symbol">(</a><a id="616" href="Agda.Builtin.Reflection.html#3808" class="InductiveConstructor">Rfl.string</a> <a id="627" href="SMT.Backend.Base.html#561" class="Bound">solver</a><a id="633" class="Symbol">))</a> <a id="636" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="638" href="Reflection.Argument.html#1071" class="InductiveConstructor">Rfl.vArg</a> <a id="647" href="SMT.Backend.Base.html#568" class="Bound">A</a> <a id="649" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="651" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="653" class="Symbol">)</a>


<a id="657" class="Keyword">module</a> <a id="Solver"></a><a id="664" href="SMT.Backend.Base.html#664" class="Module">Solver</a> <a id="671" class="Symbol">{</a><a id="672" href="SMT.Backend.Base.html#672" class="Bound">theory</a> <a id="679" class="Symbol">:</a> <a id="681" href="SMT.Theory.Base.html#2395" class="Record">Theory</a><a id="687" class="Symbol">}</a> <a id="689" class="Symbol">(</a><a id="690" href="SMT.Backend.Base.html#690" class="Bound">reflectable</a> <a id="702" class="Symbol">:</a> <a id="704" href="SMT.Theory.Reflectable.html#331" class="Record">Reflectable</a> <a id="716" href="SMT.Backend.Base.html#672" class="Bound">theory</a><a id="722" class="Symbol">)</a> <a id="724" class="Keyword">where</a>

  <a id="733" class="Keyword">open</a> <a id="738" href="SMT.Theory.Base.html#2395" class="Module">Theory</a> <a id="745" href="SMT.Backend.Base.html#672" class="Bound">theory</a>
  <a id="754" class="Keyword">open</a> <a id="759" href="SMT.Theory.Reflectable.html#331" class="Module">Reflectable</a> <a id="771" href="SMT.Backend.Base.html#690" class="Bound">reflectable</a>
  <a id="785" class="Keyword">open</a> <a id="790" class="Keyword">import</a> <a id="797" href="SMT.Script.html" class="Module">SMT.Script</a> <a id="808" href="SMT.Backend.Base.html#690" class="Bound">reflectable</a>

  <a id="823" class="Keyword">private</a>
    <a id="835" class="Keyword">variable</a>
      <a id="850" href="SMT.Backend.Base.html#850" class="Generalizable">Γ</a> <a id="852" class="Symbol">:</a> <a id="854" href="SMT.Script.Base.html#1088" class="Function">Ctxt</a>
      <a id="865" href="SMT.Backend.Base.html#865" class="Generalizable">Ξ</a> <a id="867" class="Symbol">:</a> <a id="869" href="SMT.Script.Base.html#4866" class="Function">OutputCtxt</a>

    <a id="885" class="Comment">-- Instantiate the arguments to a Π-type with the values in a Model.</a>
    <a id="958" class="Comment">--</a>
    <a id="965" class="Comment">-- NOTE: We assume all declare-consts are up front, which is what we return</a>
    <a id="1045" class="Comment">--       from reflectToRawScript. Possibly, the output of quoteInterpValues</a>
    <a id="1125" class="Comment">--       needs to be reversed.</a>
    <a id="1160" class="Comment">--</a>
    <a id="Solver.piApply"></a><a id="1167" href="SMT.Backend.Base.html#1167" class="Function">piApply</a> <a id="1175" class="Symbol">:</a> <a id="1177" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Rfl.Term</a> <a id="1186" class="Symbol">→</a> <a id="1188" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="1193" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Rfl.Term</a> <a id="1202" class="Symbol">→</a> <a id="1204" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Rfl.Term</a>
    <a id="1217" href="SMT.Backend.Base.html#1167" class="Function">piApply</a> <a id="1225" href="SMT.Backend.Base.html#1225" class="Bound">goal</a> <a id="1230" href="SMT.Backend.Base.html#1230" class="Bound">vs</a> <a id="1233" class="Symbol">=</a> <a id="1235" href="SMT.Backend.Base.html#1272" class="Function">piApply′</a> <a id="1244" href="SMT.Backend.Base.html#1225" class="Bound">goal</a> <a id="1249" href="SMT.Backend.Base.html#1230" class="Bound">vs</a>
      <a id="1258" class="Keyword">where</a>
        <a id="1272" href="SMT.Backend.Base.html#1272" class="Function">piApply′</a> <a id="1281" class="Symbol">:</a> <a id="1283" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Rfl.Term</a> <a id="1292" class="Symbol">→</a> <a id="1294" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="1299" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Rfl.Term</a> <a id="1308" class="Symbol">→</a> <a id="1310" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Rfl.Term</a>
        <a id="1327" href="SMT.Backend.Base.html#1272" class="Function">piApply′</a> <a id="1336" href="SMT.Backend.Base.html#1336" class="Bound">t</a> <a id="1338" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="1341" class="Symbol">=</a> <a id="1343" href="SMT.Backend.Base.html#1336" class="Bound">t</a>
        <a id="1353" href="SMT.Backend.Base.html#1272" class="Function">piApply′</a> <a id="1362" class="Symbol">(</a><a id="1363" href="Agda.Builtin.Reflection.html#4636" class="InductiveConstructor">Rfl.pi</a> <a id="1370" class="Symbol">(</a><a id="1371" href="Agda.Builtin.Reflection.html#3291" class="InductiveConstructor">Rfl.arg</a> <a id="1379" class="Symbol">_</a> <a id="1381" href="SMT.Backend.Base.html#1381" class="Bound">a</a><a id="1382" class="Symbol">)</a> <a id="1384" class="Symbol">(</a><a id="1385" href="Agda.Builtin.Reflection.html#3538" class="InductiveConstructor">Rfl.abs</a> <a id="1393" href="SMT.Backend.Base.html#1393" class="Bound">x</a> <a id="1395" href="SMT.Backend.Base.html#1395" class="Bound">b</a><a id="1396" class="Symbol">))</a> <a id="1399" class="Symbol">(</a><a id="1400" href="SMT.Backend.Base.html#1400" class="Bound">v</a> <a id="1402" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1404" href="SMT.Backend.Base.html#1404" class="Bound">args</a><a id="1408" class="Symbol">)</a> <a id="1410" class="Symbol">=</a>
          <a id="1422" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">Rfl.def</a> <a id="1430" class="Symbol">(</a><a id="1431" class="Keyword">quote</a> <a id="1437" href="Function.Base.html#3839" class="Function Operator">Function._$′_</a><a id="1450" class="Symbol">)</a>
                  <a id="1470" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="1472" href="Reflection.Argument.html#1126" class="InductiveConstructor">Rfl.hArg</a> <a id="1481" href="Agda.Builtin.Reflection.html#4804" class="InductiveConstructor">Rfl.unknown</a>
                  <a id="1511" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1513" href="Reflection.Argument.html#1126" class="InductiveConstructor">Rfl.hArg</a> <a id="1522" href="SMT.Backend.Base.html#1381" class="Bound">a</a>
                  <a id="1542" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1544" href="Reflection.Argument.html#1126" class="InductiveConstructor">Rfl.hArg</a> <a id="1553" href="Agda.Builtin.Reflection.html#4804" class="InductiveConstructor">Rfl.unknown</a>
                  <a id="1583" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1585" href="Reflection.Argument.html#1126" class="InductiveConstructor">Rfl.hArg</a> <a id="1594" href="Agda.Builtin.Reflection.html#4804" class="InductiveConstructor">Rfl.unknown</a>
                  <a id="1624" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1626" href="Reflection.Argument.html#1071" class="InductiveConstructor">Rfl.vArg</a> <a id="1635" class="Symbol">(</a><a id="1636" href="Agda.Builtin.Reflection.html#4518" class="InductiveConstructor">Rfl.lam</a> <a id="1644" href="Agda.Builtin.Reflection.html#2763" class="InductiveConstructor">Rfl.visible</a> <a id="1656" class="Symbol">(</a><a id="1657" href="Agda.Builtin.Reflection.html#3538" class="InductiveConstructor">Rfl.abs</a> <a id="1665" href="SMT.Backend.Base.html#1393" class="Bound">x</a> <a id="1667" class="Symbol">(</a><a id="1668" href="SMT.Backend.Base.html#1167" class="Function">piApply</a> <a id="1676" href="SMT.Backend.Base.html#1395" class="Bound">b</a> <a id="1678" href="SMT.Backend.Base.html#1404" class="Bound">args</a><a id="1682" class="Symbol">)))</a>
                  <a id="1704" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1706" href="Reflection.Argument.html#1071" class="InductiveConstructor">Rfl.vArg</a> <a id="1715" href="SMT.Backend.Base.html#1400" class="Bound">v</a>
                  <a id="1735" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1737" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>
        <a id="1748" href="SMT.Backend.Base.html#1272" class="CatchallClause Function">piApply′</a><a id="1756" class="CatchallClause"> </a><a id="1757" href="SMT.Backend.Base.html#1757" class="CatchallClause Bound">t</a><a id="1758" class="CatchallClause"> </a><a id="1759" class="CatchallClause Symbol">_</a> <a id="1761" class="Symbol">=</a> <a id="1763" href="SMT.Backend.Base.html#1757" class="Bound">t</a> <a id="1765" class="Comment">-- impossible?</a>

    <a id="Solver.counterExampleFmt"></a><a id="1785" href="SMT.Backend.Base.html#1785" class="Function">counterExampleFmt</a> <a id="1803" class="Symbol">:</a> <a id="1805" href="SMT.Script.Base.html#10069" class="Function">VarNames</a> <a id="1814" href="SMT.Backend.Base.html#850" class="Generalizable">Γ</a> <a id="1816" class="Symbol">→</a> <a id="1818" href="SMT.Script.Base.html#7573" class="Function">ValueInterps</a> <a id="1831" href="SMT.Backend.Base.html#850" class="Generalizable">Γ</a> <a id="1833" class="Symbol">→</a> <a id="1835" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="1840" href="Agda.Builtin.Reflection.html#7175" class="Datatype">Rfl.ErrorPart</a> <a id="1854" class="Symbol">→</a> <a id="1856" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="1861" href="Agda.Builtin.Reflection.html#7175" class="Datatype">Rfl.ErrorPart</a>
    <a id="1879" href="SMT.Backend.Base.html#1785" class="Function">counterExampleFmt</a> <a id="1897" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a>       <a id="1906" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a>      <a id="1914" href="SMT.Backend.Base.html#1914" class="Bound">acc</a> <a id="1918" class="Symbol">=</a> <a id="1920" href="SMT.Backend.Base.html#1914" class="Bound">acc</a>
    <a id="1928" href="SMT.Backend.Base.html#1785" class="Function">counterExampleFmt</a> <a id="1946" class="Symbol">(</a><a id="1947" href="SMT.Backend.Base.html#1947" class="Bound">x</a> <a id="1949" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">∷</a> <a id="1951" href="SMT.Backend.Base.html#1951" class="Bound">xs</a><a id="1953" class="Symbol">)</a> <a id="1955" class="Symbol">(</a><a id="1956" href="SMT.Backend.Base.html#1956" class="Bound">v</a> <a id="1958" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">∷</a> <a id="1960" href="SMT.Backend.Base.html#1960" class="Bound">m</a><a id="1961" class="Symbol">)</a> <a id="1963" href="SMT.Backend.Base.html#1963" class="Bound">acc</a> <a id="1967" class="Symbol">=</a>
      <a id="1975" href="SMT.Backend.Base.html#1785" class="Function">counterExampleFmt</a> <a id="1993" href="SMT.Backend.Base.html#1951" class="Bound">xs</a> <a id="1996" href="SMT.Backend.Base.html#1960" class="Bound">m</a> <a id="1998" href="Function.Base.html#1919" class="Function Operator">$</a>
        <a id="2008" href="Agda.Builtin.Reflection.html#7199" class="InductiveConstructor">Rfl.strErr</a> <a id="2019" class="String">&quot;  &quot;</a> <a id="2024" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="2026" href="Agda.Builtin.Reflection.html#7199" class="InductiveConstructor">Rfl.strErr</a> <a id="2037" href="SMT.Backend.Base.html#1947" class="Bound">x</a> <a id="2039" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="2041" href="Agda.Builtin.Reflection.html#7199" class="InductiveConstructor">Rfl.strErr</a> <a id="2052" class="String">&quot; = &quot;</a> <a id="2058" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="2060" href="Agda.Builtin.Reflection.html#7230" class="InductiveConstructor">Rfl.termErr</a> <a id="2072" href="SMT.Backend.Base.html#1956" class="Bound">v</a> <a id="2074" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="2076" href="Agda.Builtin.Reflection.html#7199" class="InductiveConstructor">Rfl.strErr</a> <a id="2087" class="String">&quot;\n&quot;</a> <a id="2092" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="2094" href="SMT.Backend.Base.html#1963" class="Bound">acc</a>

  <a id="Solver.typeErrorCounterExample"></a><a id="2101" href="SMT.Backend.Base.html#2101" class="Function">typeErrorCounterExample</a> <a id="2125" class="Symbol">:</a> <a id="2127" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Rfl.Term</a> <a id="2136" class="Symbol">→</a> <a id="2138" href="SMT.Script.Base.html#9221" class="Datatype">Script</a> <a id="2145" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="2148" href="SMT.Backend.Base.html#850" class="Generalizable">Γ</a> <a id="2150" href="SMT.Backend.Base.html#865" class="Generalizable">Ξ</a> <a id="2152" class="Symbol">→</a> <a id="2154" href="SMT.Script.Base.html#5716" class="Datatype">Model</a> <a id="2160" href="SMT.Backend.Base.html#850" class="Generalizable">Γ</a> <a id="2162" class="Symbol">→</a> <a id="2164" href="Agda.Builtin.Reflection.html#7500" class="Postulate">Rfl.TC</a> <a id="2171" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
  <a id="2175" href="SMT.Backend.Base.html#2101" class="Function">typeErrorCounterExample</a> <a id="2199" class="Symbol">{</a><a id="2200" href="SMT.Backend.Base.html#2200" class="Bound">Γ</a><a id="2201" class="Symbol">}</a> <a id="2203" href="SMT.Backend.Base.html#2203" class="Bound">goal</a> <a id="2208" href="SMT.Backend.Base.html#2208" class="Bound">scr</a> <a id="2212" href="SMT.Backend.Base.html#2212" class="Bound">vs</a> <a id="2215" class="Symbol">=</a> <a id="2217" class="Keyword">do</a>
    <a id="2224" class="Keyword">let</a> <a id="2228" href="SMT.Backend.Base.html#2228" class="Bound">`vs</a> <a id="2232" class="Symbol">=</a> <a id="2234" href="SMT.Script.Base.html#7697" class="Function">quoteInterpValues</a> <a id="2252" href="SMT.Backend.Base.html#2212" class="Bound">vs</a>
    <a id="2259" href="SMT.Backend.Base.html#2259" class="Bound">instGoal</a> <a id="2268" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="2270" href="Agda.Builtin.Reflection.html#7855" class="Postulate">Rfl.normalise</a> <a id="2284" class="Symbol">(</a><a id="2285" href="SMT.Backend.Base.html#1167" class="Function">piApply</a> <a id="2293" href="SMT.Backend.Base.html#2203" class="Bound">goal</a> <a id="2298" class="Symbol">(</a><a id="2299" href="Data.List.Base.html#9441" class="Function">List.reverse</a> <a id="2312" href="Function.Base.html#1031" class="Function Operator">∘</a> <a id="2314" href="Data.List.Base.html#1497" class="Function">List.map</a> <a id="2323" href="Agda.Builtin.Sigma.html#264" class="Field">proj₂</a> <a id="2329" href="Function.Base.html#1031" class="Function Operator">∘</a> <a id="2331" href="Data.List.Relation.Unary.All.html#2917" class="Function">All.toList</a> <a id="2342" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="2344" href="SMT.Backend.Base.html#2228" class="Bound">`vs</a><a id="2347" class="Symbol">))</a>
    <a id="2354" href="Reflection.TypeChecking.Format.html#2592" class="Function">Rfl.typeErrorFmt</a> <a id="2371" class="String">&quot;Found counter-example:\n%erefuting %t&quot;</a>
      <a id="2417" class="Symbol">(</a><a id="2418" href="SMT.Backend.Base.html#1785" class="Function">counterExampleFmt</a> <a id="2436" class="Symbol">(</a><a id="2437" href="SMT.Script.Base.html#10579" class="Function">scriptVarNames</a> <a id="2452" href="SMT.Backend.Base.html#2208" class="Bound">scr</a><a id="2455" class="Symbol">)</a> <a id="2457" href="SMT.Backend.Base.html#2228" class="Bound">`vs</a> <a id="2461" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="2463" class="Symbol">)</a> <a id="2465" href="SMT.Backend.Base.html#2259" class="Bound">instGoal</a>

  <a id="Solver.solve"></a><a id="2477" href="SMT.Backend.Base.html#2477" class="Function">solve</a> <a id="2483" class="Symbol">:</a> <a id="2485" href="Agda.Builtin.String.html#336" class="Postulate">String</a> <a id="2492" class="Symbol">→</a> <a id="2494" class="Symbol">(∀</a> <a id="2497" class="Symbol">{</a><a id="2498" href="SMT.Backend.Base.html#2498" class="Bound">Γ</a> <a id="2500" href="SMT.Backend.Base.html#2500" class="Bound">ξ</a> <a id="2502" href="SMT.Backend.Base.html#2502" class="Bound">Ξ</a><a id="2503" class="Symbol">}</a> <a id="2505" class="Symbol">→</a> <a id="2507" href="SMT.Script.Base.html#9221" class="Datatype">Script</a> <a id="2514" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="2517" href="SMT.Backend.Base.html#2498" class="Bound">Γ</a> <a id="2519" class="Symbol">(</a><a id="2520" href="SMT.Backend.Base.html#2500" class="Bound">ξ</a> <a id="2522" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="2524" href="SMT.Backend.Base.html#2502" class="Bound">Ξ</a><a id="2525" class="Symbol">)</a> <a id="2527" class="Symbol">→</a> <a id="2529" href="Agda.Builtin.Reflection.html#7500" class="Postulate">Rfl.TC</a> <a id="2536" class="Symbol">(</a><a id="2537" href="SMT.Script.Base.html#6381" class="Datatype">Outputs</a> <a id="2545" class="Symbol">(</a><a id="2546" href="SMT.Backend.Base.html#2500" class="Bound">ξ</a> <a id="2548" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="2550" href="SMT.Backend.Base.html#2502" class="Bound">Ξ</a><a id="2551" class="Symbol">)))</a> <a id="2555" class="Symbol">→</a> <a id="2557" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Rfl.Term</a> <a id="2566" class="Symbol">→</a> <a id="2568" href="Agda.Builtin.Reflection.html#7500" class="Postulate">Rfl.TC</a> <a id="2575" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
  <a id="2579" href="SMT.Backend.Base.html#2477" class="Function">solve</a> <a id="2585" href="SMT.Backend.Base.html#2585" class="Bound">name</a> <a id="2590" href="SMT.Backend.Base.html#2590" class="Bound">solver</a> <a id="2597" href="SMT.Backend.Base.html#2597" class="Bound">hole</a> <a id="2602" class="Symbol">=</a> <a id="2604" class="Keyword">do</a>
    <a id="2611" href="SMT.Backend.Base.html#2611" class="Bound">goal</a> <a id="2616" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="2618" href="Agda.Builtin.Reflection.html#7776" class="Postulate">Rfl.inferType</a> <a id="2632" href="SMT.Backend.Base.html#2597" class="Bound">hole</a>
    <a id="2641" href="SMT.Backend.Base.html#2641" class="Bound">Γ</a> <a id="2643" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2645" href="SMT.Backend.Base.html#2645" class="Bound">scr</a> <a id="2649" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="2651" href="SMT.Script.Reflection.html#5070" class="Function">reflectToScript</a> <a id="2667" href="SMT.Backend.Base.html#2611" class="Bound">goal</a>
    <a id="2676" class="Keyword">let</a> <a id="2680" href="SMT.Backend.Base.html#2680" class="Bound">scr′</a> <a id="2685" class="Symbol">=</a> <a id="2687" href="SMT.Backend.Base.html#2645" class="Bound">scr</a> <a id="2691" href="SMT.Script.Base.html#9391" class="Function Operator">◆</a> <a id="2693" href="SMT.Script.Base.html#9082" class="InductiveConstructor">get-model</a> <a id="2703" href="SMT.Script.Base.html#9306" class="InductiveConstructor Operator">∷</a> <a id="2705" href="SMT.Script.Base.html#9284" class="InductiveConstructor">[]</a>
    <a id="2712" href="SMT.Backend.Base.html#2712" class="Bound">qm</a> <a id="2715" href="SMT.Script.Base.html#6441" class="InductiveConstructor Operator">∷</a> <a id="2717" href="SMT.Script.Base.html#6422" class="InductiveConstructor">[]</a> <a id="2720" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">←</a> <a id="2722" href="SMT.Backend.Base.html#2590" class="Bound">solver</a> <a id="2729" href="SMT.Backend.Base.html#2680" class="Bound">scr′</a>
    <a id="2738" href="Function.Base.html#4121" class="Function Operator">case</a> <a id="2743" href="SMT.Backend.Base.html#2712" class="Bound">qm</a> <a id="2746" href="Function.Base.html#4121" class="Function Operator">of</a> <a id="2749" class="Symbol">λ</a> <a id="2751" class="Keyword">where</a>
      <a id="2763" class="Symbol">(</a><a id="2764" href="SMT.Script.Base.html#5035" class="InductiveConstructor">sat</a>     <a id="2772" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2774" href="SMT.Backend.Base.html#2774" class="Bound">m</a><a id="2775" class="Symbol">)</a> <a id="2777" class="Symbol">→</a> <a id="2779" href="SMT.Backend.Base.html#2101" class="Function">typeErrorCounterExample</a> <a id="2803" href="SMT.Backend.Base.html#2611" class="Bound">goal</a> <a id="2808" href="SMT.Backend.Base.html#2680" class="Bound">scr′</a> <a id="2813" href="SMT.Backend.Base.html#2774" class="Bound">m</a>
      <a id="2821" class="Symbol">(</a><a id="2822" href="SMT.Script.Base.html#5051" class="InductiveConstructor">unsat</a>   <a id="2830" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2832" class="Symbol">_)</a> <a id="2835" class="Symbol">→</a> <a id="2837" href="Agda.Builtin.Reflection.html#7673" class="Postulate">Rfl.unify</a> <a id="2847" href="SMT.Backend.Base.html#2597" class="Bound">hole</a> <a id="2852" class="Symbol">(</a><a id="2853" href="SMT.Backend.Base.html#497" class="Function">`because</a> <a id="2862" href="SMT.Backend.Base.html#2585" class="Bound">name</a> <a id="2867" href="SMT.Backend.Base.html#2611" class="Bound">goal</a><a id="2871" class="Symbol">)</a>
      <a id="2879" class="Symbol">(</a><a id="2880" href="SMT.Script.Base.html#5067" class="InductiveConstructor">unknown</a> <a id="2888" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2890" class="Symbol">_)</a> <a id="2893" class="Symbol">→</a> <a id="2895" href="Reflection.TypeChecking.Format.html#2592" class="Function">Rfl.typeErrorFmt</a> <a id="2912" class="String">&quot;Solver returned &#39;unknown&#39;&quot;</a>
</pre></body></html>
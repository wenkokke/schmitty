<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>SMT.Theories.Ints.Reflection</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Keyword">module</a> <a id="8" href="SMT.Theories.Ints.Reflection.html" class="Module">SMT.Theories.Ints.Reflection</a> <a id="37" class="Keyword">where</a>


<a id="45" class="Keyword">open</a> <a id="50" class="Keyword">import</a> <a id="57" href="Data.Integer.html" class="Module">Data.Integer</a> <a id="70" class="Symbol">as</a> <a id="73" class="Module">Int</a> <a id="77" class="Keyword">using</a> <a id="83" class="Symbol">(</a><a id="84" href="Agda.Builtin.Int.html#246" class="Datatype">ℤ</a><a id="85" class="Symbol">;</a> <a id="87" href="Agda.Builtin.Int.html#264" class="InductiveConstructor">+_</a><a id="89" class="Symbol">;</a> <a id="91" href="Agda.Builtin.Int.html#291" class="InductiveConstructor">-[1+_]</a><a id="97" class="Symbol">)</a> <a id="99" class="Keyword">renaming</a> <a id="108" class="Symbol">(</a><a id="109" href="Data.Integer.html#784" class="Function">show</a> <a id="114" class="Symbol">to</a> <a id="show"></a><a id="117" href="SMT.Theories.Ints.Reflection.html#117" class="Function">showℤ</a><a id="122" class="Symbol">)</a>
<a id="124" class="Keyword">open</a> <a id="129" class="Keyword">import</a> <a id="136" href="Data.Maybe.html" class="Module">Data.Maybe</a> <a id="147" class="Symbol">as</a> <a id="150" class="Module">Maybe</a> <a id="156" class="Keyword">using</a> <a id="162" class="Symbol">(</a><a id="163" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a><a id="168" class="Symbol">;</a> <a id="170" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a><a id="177" class="Symbol">;</a> <a id="179" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a><a id="183" class="Symbol">)</a>
<a id="185" class="Keyword">open</a> <a id="190" class="Keyword">import</a> <a id="197" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a> <a id="211" class="Symbol">as</a> <a id="214" class="Module">Nat</a> <a id="218" class="Keyword">using</a> <a id="224" class="Symbol">(</a><a id="225" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="226" class="Symbol">)</a>
<a id="228" class="Keyword">open</a> <a id="233" class="Keyword">import</a> <a id="240" href="Data.Nat.Show.html" class="Module">Data.Nat.Show</a> <a id="254" class="Keyword">renaming</a> <a id="263" class="Symbol">(</a><a id="264" href="Data.Nat.Show.html#1076" class="Function">show</a> <a id="269" class="Symbol">to</a> <a id="show"></a><a id="272" href="SMT.Theories.Ints.Reflection.html#272" class="Function">showℕ</a><a id="277" class="Symbol">)</a>
<a id="279" class="Keyword">open</a> <a id="284" class="Keyword">import</a> <a id="291" href="Data.List.html" class="Module">Data.List</a> <a id="301" class="Symbol">as</a> <a id="304" class="Module">List</a> <a id="309" class="Keyword">using</a> <a id="315" class="Symbol">(</a><a id="316" href="Agda.Builtin.List.html#148" class="Datatype">List</a><a id="320" class="Symbol">;</a> <a id="322" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">_∷_</a><a id="325" class="Symbol">;</a> <a id="327" href="Data.List.Base.html#9981" class="InductiveConstructor">[]</a><a id="329" class="Symbol">)</a>
<a id="331" class="Keyword">open</a> <a id="336" class="Keyword">import</a> <a id="343" href="Data.List.Relation.Unary.All.html" class="Module">Data.List.Relation.Unary.All</a> <a id="372" class="Symbol">as</a> <a id="375" class="Module">All</a> <a id="379" class="Keyword">using</a> <a id="385" class="Symbol">(</a><a id="386" href="Data.List.Relation.Unary.All.html#1397" class="Datatype">All</a><a id="389" class="Symbol">;</a> <a id="391" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">_∷_</a><a id="394" class="Symbol">;</a> <a id="396" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a><a id="398" class="Symbol">)</a>
<a id="400" class="Keyword">open</a> <a id="405" class="Keyword">import</a> <a id="412" href="Data.Product.html" class="Module">Data.Product</a> <a id="425" class="Symbol">as</a> <a id="428" class="Module">Prod</a> <a id="433" class="Keyword">using</a> <a id="439" class="Symbol">(</a><a id="440" href="Data.Product.html#916" class="Function">Σ-syntax</a><a id="448" class="Symbol">;</a> <a id="450" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a><a id="453" class="Symbol">)</a>
<a id="455" class="Keyword">import</a> <a id="462" href="Reflection.html" class="Module">Reflection</a> <a id="473" class="Symbol">as</a> <a id="476" class="Module">Rfl</a>
<a id="480" class="Keyword">open</a> <a id="485" class="Keyword">import</a> <a id="492" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="530" class="Symbol">as</a> <a id="533" class="Module">PropEq</a> <a id="540" class="Keyword">using</a> <a id="546" class="Symbol">(</a><a id="547" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="550" class="Symbol">;</a> <a id="552" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="556" class="Symbol">)</a>
<a id="558" class="Keyword">open</a> <a id="563" class="Keyword">import</a> <a id="570" href="SMT.Theory.html" class="Module">SMT.Theory</a>
<a id="581" class="Keyword">open</a> <a id="586" class="Keyword">import</a> <a id="593" href="SMT.Theory.Reflection.html" class="Module">SMT.Theory.Reflection</a>
<a id="615" class="Keyword">open</a> <a id="620" class="Keyword">import</a> <a id="627" href="SMT.Theories.Core.html" class="Module">SMT.Theories.Core</a> <a id="645" class="Symbol">as</a> <a id="648" class="Module">Core</a> <a id="653" class="Keyword">hiding</a> <a id="660" class="Symbol">(</a><a id="661" href="SMT.Theories.Core.Base.html#593" class="InductiveConstructor">BOOL</a><a id="665" class="Symbol">)</a>
<a id="667" class="Keyword">open</a> <a id="672" class="Keyword">import</a> <a id="679" href="SMT.Theories.Core.Extensions.html" class="Module">SMT.Theories.Core.Extensions</a>
<a id="708" class="Keyword">open</a> <a id="713" class="Keyword">import</a> <a id="720" href="SMT.Theories.Ints.Base.html" class="Module">SMT.Theories.Ints.Base</a> <a id="743" class="Symbol">as</a> <a id="746" class="Module">Ints</a>
<a id="751" class="Keyword">open</a> <a id="756" class="Keyword">import</a> <a id="763" href="SMT.Script.Base.html" class="Module">SMT.Script.Base</a> <a id="779" href="SMT.Theories.Ints.Base.html#4608" class="Function">Ints.baseTheory</a>


<a id="797" class="Comment">-----------</a>
<a id="809" class="Comment">-- Sorts --</a>
<a id="821" class="Comment">-----------</a>

<a id="sorts"></a><a id="834" href="SMT.Theories.Ints.Reflection.html#834" class="Function">sorts</a> <a id="840" class="Symbol">:</a> <a id="842" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="847" href="SMT.Theories.Ints.Base.html#812" class="Datatype">Sort</a>
<a id="852" href="SMT.Theories.Ints.Reflection.html#834" class="Function">sorts</a> <a id="858" class="Symbol">=</a> <a id="860" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a> <a id="864" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="866" href="Data.List.Base.html#1497" class="Function">List.map</a> <a id="875" href="SMT.Theories.Ints.Base.html#832" class="InductiveConstructor">CORE</a> <a id="880" href="SMT.Theories.Core.Reflection.html#763" class="Function">coreSorts</a>


<a id="checkSort"></a><a id="892" href="SMT.Theories.Ints.Reflection.html#892" class="Function">checkSort</a> <a id="902" class="Symbol">:</a> <a id="904" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Rfl.Term</a> <a id="913" class="Symbol">→</a> <a id="915" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="921" href="SMT.Theories.Ints.Base.html#812" class="Datatype">Sort</a>
<a id="926" href="SMT.Theories.Ints.Reflection.html#892" class="Function">checkSort</a> <a id="936" class="Symbol">(</a><a id="937" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">Rfl.def</a> <a id="945" class="Symbol">(</a><a id="946" class="Keyword">quote</a> <a id="952" href="Agda.Builtin.Int.html#246" class="Datatype">ℤ</a><a id="953" class="Symbol">)</a> <a id="955" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="957" class="Symbol">)</a> <a id="959" class="Symbol">=</a> <a id="961" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="966" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a>
<a id="970" href="SMT.Theories.Ints.Reflection.html#892" class="CatchallClause Function">checkSort</a><a id="979" class="CatchallClause"> </a><a id="980" href="SMT.Theories.Ints.Reflection.html#980" class="CatchallClause Bound">t</a>                      <a id="1003" class="Symbol">=</a> <a id="1005" href="Data.Maybe.Base.html#2020" class="Function">Maybe.map</a> <a id="1015" href="SMT.Theories.Ints.Base.html#832" class="InductiveConstructor">CORE</a> <a id="1020" class="Symbol">(</a><a id="1021" href="SMT.Theories.Core.Reflection.html#813" class="Function">checkCoreSort</a> <a id="1035" href="SMT.Theories.Ints.Reflection.html#980" class="Bound">t</a><a id="1036" class="Symbol">)</a>


<a id="1040" class="Comment">--------------</a>
<a id="1055" class="Comment">-- Literals --</a>
<a id="1070" class="Comment">--------------</a>

<a id="1086" class="Keyword">private</a>
  <a id="1096" class="Keyword">pattern</a> <a id="`nat"></a><a id="1104" href="SMT.Theories.Ints.Reflection.html#1104" class="InductiveConstructor">`nat</a>    <a id="1112" href="SMT.Theories.Ints.Reflection.html#1124" class="Bound">n</a> <a id="1114" class="Symbol">=</a> <a id="1116" href="Agda.Builtin.Reflection.html#3672" class="InductiveConstructor">Rfl.nat</a> <a id="1124" href="SMT.Theories.Ints.Reflection.html#1124" class="Bound">n</a>

<a id="checkLiteral"></a><a id="1127" href="SMT.Theories.Ints.Reflection.html#1127" class="Function">checkLiteral</a> <a id="1140" class="Symbol">:</a> <a id="1142" class="Symbol">(</a><a id="1143" href="SMT.Theories.Ints.Reflection.html#1143" class="Bound">σ</a> <a id="1145" class="Symbol">:</a> <a id="1147" href="SMT.Theories.Ints.Base.html#812" class="Datatype">Sort</a><a id="1151" class="Symbol">)</a> <a id="1153" class="Symbol">→</a> <a id="1155" href="Agda.Builtin.Reflection.html#3650" class="Datatype">Rfl.Literal</a> <a id="1167" class="Symbol">→</a> <a id="1169" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="1175" class="Symbol">(</a><a id="1176" href="SMT.Theories.Ints.Base.html#3040" class="Datatype">Literal</a> <a id="1184" href="SMT.Theories.Ints.Reflection.html#1143" class="Bound">σ</a><a id="1185" class="Symbol">)</a>
<a id="1187" href="SMT.Theories.Ints.Reflection.html#1127" class="Function">checkLiteral</a> <a id="1200" class="Symbol">(</a><a id="1201" href="SMT.Theories.Ints.Base.html#832" class="InductiveConstructor">CORE</a> <a id="1206" href="SMT.Theories.Ints.Reflection.html#1206" class="Bound">φ</a><a id="1207" class="Symbol">)</a> <a id="1209" href="SMT.Theories.Ints.Reflection.html#1209" class="Bound">x</a>         <a id="1219" class="Symbol">=</a> <a id="1221" href="Data.Maybe.Base.html#2020" class="Function">Maybe.map</a> <a id="1231" href="SMT.Theories.Ints.Base.html#3069" class="InductiveConstructor">core</a> <a id="1236" class="Symbol">(</a><a id="1237" href="SMT.Theories.Core.Reflection.html#989" class="Function">checkCoreLiteral</a> <a id="1254" href="SMT.Theories.Ints.Reflection.html#1206" class="Bound">φ</a> <a id="1256" href="SMT.Theories.Ints.Reflection.html#1209" class="Bound">x</a><a id="1257" class="Symbol">)</a>
<a id="1259" href="SMT.Theories.Ints.Reflection.html#1127" class="Function">checkLiteral</a> <a id="1272" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a>      <a id="1281" class="Symbol">(</a><a id="1282" href="SMT.Theories.Ints.Reflection.html#1104" class="InductiveConstructor">`nat</a> <a id="1287" href="SMT.Theories.Ints.Reflection.html#1287" class="Bound">n</a><a id="1288" class="Symbol">)</a>  <a id="1291" class="Symbol">=</a> <a id="1293" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="1298" class="Symbol">(</a><a id="1299" href="SMT.Theories.Ints.Base.html#3111" class="InductiveConstructor">nat</a> <a id="1303" href="SMT.Theories.Ints.Reflection.html#1287" class="Bound">n</a><a id="1304" class="Symbol">)</a>
<a id="1306" href="SMT.Theories.Ints.Reflection.html#1127" class="CatchallClause Function">checkLiteral</a><a id="1318" class="CatchallClause"> </a><a id="1319" href="SMT.Theories.Ints.Base.html#864" class="CatchallClause InductiveConstructor">INT</a><a id="1322" class="CatchallClause">      </a><a id="1328" class="CatchallClause Symbol">_</a>         <a id="1338" class="Symbol">=</a> <a id="1340" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>


<a id="1350" class="Comment">-----------------</a>
<a id="1368" class="Comment">-- Identifiers --</a>
<a id="1386" class="Comment">-----------------</a>

<a id="1405" class="Keyword">private</a>
  <a id="1415" class="Keyword">pattern</a> <a id="`eq"></a><a id="1423" href="SMT.Theories.Ints.Reflection.html#1423" class="InductiveConstructor">`eq</a>     <a id="1431" class="Symbol">=</a> <a id="1433" class="Keyword">quote</a> <a id="1439" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">PropEq._≡_</a>
  <a id="1452" class="Keyword">pattern</a> <a id="`neq"></a><a id="1460" href="SMT.Theories.Ints.Reflection.html#1460" class="InductiveConstructor">`neq</a>    <a id="1468" class="Symbol">=</a> <a id="1470" class="Keyword">quote</a> <a id="1476" href="Relation.Binary.PropositionalEquality.Core.html#830" class="Function Operator">PropEq._≢_</a>
  <a id="1489" class="Comment">-- NOTE: We&#39;re interpreting BOOL to be Set. Unfortunately, that means that `ite`</a>
  <a id="1572" class="Comment">--       cannot really be given a sensible interpretation. (Unless, perhaps, we</a>
  <a id="1654" class="Comment">--       involve Dec.)</a>
  <a id="1679" class="Comment">--</a>
  <a id="1684" class="Comment">-- pattern `ite = ?</a>
  <a id="1706" class="Keyword">pattern</a> <a id="`neg"></a><a id="1714" href="SMT.Theories.Ints.Reflection.html#1714" class="InductiveConstructor">`neg</a>    <a id="1722" class="Symbol">=</a> <a id="1724" class="Keyword">quote</a> <a id="1730" href="Data.Integer.Base.html#4169" class="Function Operator">Int.-_</a>
  <a id="1739" class="Keyword">pattern</a> <a id="`sub"></a><a id="1747" href="SMT.Theories.Ints.Reflection.html#1747" class="InductiveConstructor">`sub</a>    <a id="1755" class="Symbol">=</a> <a id="1757" class="Keyword">quote</a> <a id="1763" href="Data.Integer.Base.html#4566" class="Function Operator">Int._-_</a>
  <a id="1773" class="Keyword">pattern</a> <a id="`add"></a><a id="1781" href="SMT.Theories.Ints.Reflection.html#1781" class="InductiveConstructor">`add</a>    <a id="1789" class="Symbol">=</a> <a id="1791" class="Keyword">quote</a> <a id="1797" href="Data.Integer.Base.html#4387" class="Function Operator">Int._+_</a>
  <a id="1807" class="Keyword">pattern</a> <a id="`mul"></a><a id="1815" href="SMT.Theories.Ints.Reflection.html#1815" class="InductiveConstructor">`mul</a>    <a id="1823" class="Symbol">=</a> <a id="1825" class="Keyword">quote</a> <a id="1831" href="Data.Integer.Base.html#4712" class="Function Operator">Int._*_</a>
  <a id="1841" class="Comment">-- NOTE: Integer division and modulo are currently not defined in the standard</a>
  <a id="1922" class="Comment">--       library, so we don&#39;t map them here. Note that division by zero is</a>
  <a id="1999" class="Comment">--       allowed in SMT-LIB, so care should be taken.</a>
  <a id="2055" class="Comment">--</a>
  <a id="2060" class="Comment">-- pattern `div = ?</a>
  <a id="2082" class="Comment">-- pattern `mod = ?</a>
  <a id="2104" class="Keyword">pattern</a> <a id="`abs"></a><a id="2112" href="SMT.Theories.Ints.Reflection.html#2112" class="InductiveConstructor">`abs</a>    <a id="2120" class="Symbol">=</a> <a id="2122" class="Keyword">quote</a> <a id="2128" href="Data.Integer.Base.html#1676" class="Function Operator">Int.∣_∣</a>
  <a id="2138" class="Keyword">pattern</a> <a id="`leq"></a><a id="2146" href="SMT.Theories.Ints.Reflection.html#2146" class="InductiveConstructor">`leq</a>    <a id="2154" class="Symbol">=</a> <a id="2156" class="Keyword">quote</a> <a id="2162" href="Data.Integer.Base.html#1952" class="Datatype Operator">Int._≤_</a>
  <a id="2172" class="Keyword">pattern</a> <a id="`lt"></a><a id="2180" href="SMT.Theories.Ints.Reflection.html#2180" class="InductiveConstructor">`lt</a>     <a id="2188" class="Symbol">=</a> <a id="2190" class="Keyword">quote</a> <a id="2196" href="Data.Integer.Base.html#2117" class="Datatype Operator">Int._&lt;_</a>
  <a id="2206" class="Keyword">pattern</a> <a id="`geq"></a><a id="2214" href="SMT.Theories.Ints.Reflection.html#2214" class="InductiveConstructor">`geq</a>    <a id="2222" class="Symbol">=</a> <a id="2224" class="Keyword">quote</a> <a id="2230" href="Data.Integer.Base.html#2277" class="Function Operator">Int._≥_</a>
  <a id="2240" class="Keyword">pattern</a> <a id="`gt"></a><a id="2248" href="SMT.Theories.Ints.Reflection.html#2248" class="InductiveConstructor">`gt</a>     <a id="2256" class="Symbol">=</a> <a id="2258" class="Keyword">quote</a> <a id="2264" href="Data.Integer.Base.html#2307" class="Function Operator">Int._&gt;_</a>

  <a id="2275" class="Keyword">pattern</a> <a id="`zero"></a><a id="2283" href="SMT.Theories.Ints.Reflection.html#2283" class="InductiveConstructor">`zero</a>   <a id="2291" class="Symbol">=</a> <a id="2293" class="Keyword">quote</a> <a id="2299" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">Nat.zero</a>
  <a id="2310" class="Keyword">pattern</a> <a id="`suc"></a><a id="2318" href="SMT.Theories.Ints.Reflection.html#2318" class="InductiveConstructor">`suc</a>    <a id="2326" class="Symbol">=</a> <a id="2328" class="Keyword">quote</a> <a id="2334" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">Nat.suc</a>

  <a id="2345" class="Comment">-- NOTE: These should eventually use NAT sort, once we implement NAT sort.</a>
  <a id="`zero!"></a><a id="2422" href="SMT.Theories.Ints.Reflection.html#2422" class="Function">`zero!</a> <a id="2429" class="Symbol">:</a> <a id="2431" href="SMT.Script.Base.html#1970" class="Function">Macro</a> <a id="2437" class="Symbol">(</a><a id="2438" href="SMT.Theory.html#719" class="Function">Op₀</a> <a id="2442" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a><a id="2445" class="Symbol">)</a>
  <a id="2449" href="SMT.Theories.Ints.Reflection.html#2422" class="Function">`zero!</a> <a id="2456" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a> <a id="2459" class="Symbol">=</a> <a id="2461" href="SMT.Script.Base.html#1640" class="InductiveConstructor">lit</a> <a id="2465" class="Symbol">(</a><a id="2466" href="SMT.Theories.Ints.Base.html#3111" class="InductiveConstructor">nat</a> <a id="2470" class="Number">0</a><a id="2471" class="Symbol">)</a>

  <a id="`suc!"></a><a id="2476" href="SMT.Theories.Ints.Reflection.html#2476" class="Function">`suc!</a> <a id="2482" class="Symbol">:</a> <a id="2484" href="SMT.Script.Base.html#1970" class="Function">Macro</a> <a id="2490" class="Symbol">(</a><a id="2491" href="SMT.Theory.html#770" class="Function">Op₁</a> <a id="2495" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a><a id="2498" class="Symbol">)</a>
  <a id="2502" href="SMT.Theories.Ints.Reflection.html#2476" class="Function">`suc!</a> <a id="2508" class="Symbol">(</a><a id="2509" href="SMT.Script.Base.html#1640" class="InductiveConstructor">lit</a> <a id="2513" class="Symbol">(</a><a id="2514" href="SMT.Theories.Ints.Base.html#3111" class="InductiveConstructor">nat</a> <a id="2518" href="SMT.Theories.Ints.Reflection.html#2518" class="Bound">x</a><a id="2519" class="Symbol">)</a> <a id="2521" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">∷</a> <a id="2523" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a><a id="2525" class="Symbol">)</a> <a id="2527" class="Symbol">=</a> <a id="2529" href="SMT.Script.Base.html#1640" class="InductiveConstructor">lit</a> <a id="2533" class="Symbol">(</a><a id="2534" href="SMT.Theories.Ints.Base.html#3111" class="InductiveConstructor">nat</a> <a id="2538" class="Symbol">(</a><a id="2539" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">Nat.suc</a> <a id="2547" href="SMT.Theories.Ints.Reflection.html#2518" class="Bound">x</a><a id="2548" class="Symbol">))</a>
  <a id="2553" href="SMT.Theories.Ints.Reflection.html#2476" class="CatchallClause Function">`suc!</a><a id="2558" class="CatchallClause"> </a><a id="2559" class="CatchallClause Symbol">(</a><a id="2560" href="SMT.Theories.Ints.Reflection.html#2560" class="CatchallClause Bound">x</a><a id="2561" class="CatchallClause"> </a><a id="2562" href="Data.List.Relation.Unary.All.html#1477" class="CatchallClause InductiveConstructor Operator">∷</a><a id="2563" class="CatchallClause"> </a><a id="2564" href="Data.List.Relation.Unary.All.html#1460" class="CatchallClause InductiveConstructor">[]</a><a id="2566" class="CatchallClause Symbol">)</a>           <a id="2578" class="Symbol">=</a> <a id="2580" href="SMT.Script.Base.html#2102" class="InductiveConstructor">app₂</a> <a id="2585" href="SMT.Theories.Ints.Base.html#3675" class="InductiveConstructor">add</a> <a id="2589" class="Symbol">(</a><a id="2590" href="SMT.Script.Base.html#1640" class="InductiveConstructor">lit</a> <a id="2594" class="Symbol">(</a><a id="2595" href="SMT.Theories.Ints.Base.html#3111" class="InductiveConstructor">nat</a> <a id="2599" class="Number">1</a><a id="2600" class="Symbol">))</a> <a id="2603" href="SMT.Theories.Ints.Reflection.html#2560" class="Bound">x</a>

  <a id="2608" class="Keyword">pattern</a> <a id="`+_"></a><a id="2616" href="SMT.Theories.Ints.Reflection.html#2616" class="InductiveConstructor Operator">`+_</a>     <a id="2624" class="Symbol">=</a> <a id="2626" class="Keyword">quote</a> <a id="2632" href="Agda.Builtin.Int.html#264" class="InductiveConstructor Operator">Int.+_</a>
  <a id="2641" class="Keyword">pattern</a> <a id="`-[1+_]"></a><a id="2649" href="SMT.Theories.Ints.Reflection.html#2649" class="InductiveConstructor Operator">`-[1+_]</a> <a id="2657" class="Symbol">=</a> <a id="2659" class="Keyword">quote</a> <a id="2665" href="Agda.Builtin.Int.html#291" class="InductiveConstructor Operator">Int.-[1+_]</a>

  <a id="`+!_"></a><a id="2679" href="SMT.Theories.Ints.Reflection.html#2679" class="Function Operator">`+!_</a> <a id="2684" class="Symbol">:</a> <a id="2686" href="SMT.Script.Base.html#1970" class="Function">Macro</a> <a id="2692" class="Symbol">(</a><a id="2693" href="SMT.Theory.html#770" class="Function">Op₁</a> <a id="2697" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a><a id="2700" class="Symbol">)</a>
  <a id="2704" href="SMT.Theories.Ints.Reflection.html#2679" class="Function Operator">`+!</a> <a id="2708" class="Symbol">(</a><a id="2709" href="SMT.Theories.Ints.Reflection.html#2709" class="Bound">x</a> <a id="2711" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">∷</a> <a id="2713" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a><a id="2715" class="Symbol">)</a> <a id="2717" class="Symbol">=</a> <a id="2719" href="SMT.Theories.Ints.Reflection.html#2709" class="Bound">x</a>

  <a id="`-[1+_]!"></a><a id="2724" href="SMT.Theories.Ints.Reflection.html#2724" class="Function Operator">`-[1+_]!</a> <a id="2733" class="Symbol">:</a> <a id="2735" href="SMT.Script.Base.html#1970" class="Function">Macro</a> <a id="2741" class="Symbol">(</a><a id="2742" href="SMT.Theory.html#770" class="Function">Op₁</a> <a id="2746" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a><a id="2749" class="Symbol">)</a>
  <a id="2753" href="SMT.Theories.Ints.Reflection.html#2724" class="Function Operator">`-[1+</a> <a id="2759" href="SMT.Script.Base.html#1640" class="InductiveConstructor">lit</a> <a id="2763" class="Symbol">(</a><a id="2764" href="SMT.Theories.Ints.Base.html#3111" class="InductiveConstructor">nat</a> <a id="2768" href="SMT.Theories.Ints.Reflection.html#2768" class="Bound">x</a><a id="2769" class="Symbol">)</a> <a id="2771" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">∷</a> <a id="2773" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a> <a id="2776" href="SMT.Theories.Ints.Reflection.html#2724" class="Function Operator">]!</a> <a id="2779" class="Symbol">=</a> <a id="2781" href="SMT.Script.Base.html#1640" class="InductiveConstructor">lit</a> <a id="2785" class="Symbol">(</a><a id="2786" href="SMT.Theories.Ints.Base.html#3136" class="InductiveConstructor">int</a> <a id="2790" href="Agda.Builtin.Int.html#291" class="InductiveConstructor Operator">-[1+</a> <a id="2795" href="SMT.Theories.Ints.Reflection.html#2768" class="Bound">x</a> <a id="2797" href="Agda.Builtin.Int.html#291" class="InductiveConstructor Operator">]</a><a id="2798" class="Symbol">)</a>
  <a id="2802" href="SMT.Theories.Ints.Reflection.html#2724" class="Function Operator">`-[1+</a> <a id="2808" href="SMT.Script.Base.html#1640" class="InductiveConstructor">lit</a> <a id="2812" class="Symbol">(</a><a id="2813" href="SMT.Theories.Ints.Base.html#3136" class="InductiveConstructor">int</a> <a id="2817" href="SMT.Theories.Ints.Reflection.html#2817" class="Bound">x</a><a id="2818" class="Symbol">)</a> <a id="2820" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">∷</a> <a id="2822" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a> <a id="2825" href="SMT.Theories.Ints.Reflection.html#2724" class="Function Operator">]!</a> <a id="2828" class="Symbol">=</a> <a id="2830" href="SMT.Script.Base.html#1640" class="InductiveConstructor">lit</a> <a id="2834" class="Symbol">(</a><a id="2835" href="SMT.Theories.Ints.Base.html#3136" class="InductiveConstructor">int</a> <a id="2839" class="Symbol">(</a><a id="2840" href="Data.Integer.Base.html#4169" class="Function Operator">Int.-</a> <a id="2846" class="Symbol">(</a><a id="2847" href="Data.Integer.Base.html#1546" class="Function">Int.1ℤ</a> <a id="2854" href="Data.Integer.Base.html#4387" class="Function Operator">Int.+</a> <a id="2860" href="SMT.Theories.Ints.Reflection.html#2817" class="Bound">x</a><a id="2861" class="Symbol">)))</a>
  <a id="2867" href="SMT.Theories.Ints.Reflection.html#2724" class="CatchallClause Function Operator">`-[1+</a><a id="2872" class="CatchallClause"> </a><a id="2873" href="SMT.Theories.Ints.Reflection.html#2873" class="CatchallClause Bound">x</a><a id="2874" class="CatchallClause"> </a><a id="2875" href="Data.List.Relation.Unary.All.html#1477" class="CatchallClause InductiveConstructor Operator">∷</a><a id="2876" class="CatchallClause"> </a><a id="2877" href="Data.List.Relation.Unary.All.html#1460" class="CatchallClause InductiveConstructor">[]</a><a id="2879" class="CatchallClause"> </a><a id="2880" href="SMT.Theories.Ints.Reflection.html#2724" class="CatchallClause Function Operator">]!</a>           <a id="2893" class="Symbol">=</a> <a id="2895" href="SMT.Script.Base.html#2064" class="InductiveConstructor">app₁</a> <a id="2900" href="SMT.Theories.Ints.Base.html#3615" class="InductiveConstructor">neg</a> <a id="2904" class="Symbol">(</a><a id="2905" href="SMT.Script.Base.html#2102" class="InductiveConstructor">app₂</a> <a id="2910" href="SMT.Theories.Ints.Base.html#3675" class="InductiveConstructor">add</a> <a id="2914" class="Symbol">(</a><a id="2915" href="SMT.Script.Base.html#1640" class="InductiveConstructor">lit</a> <a id="2919" class="Symbol">(</a><a id="2920" href="SMT.Theories.Ints.Base.html#3111" class="InductiveConstructor">nat</a> <a id="2924" class="Number">1</a><a id="2925" class="Symbol">))</a> <a id="2928" href="SMT.Theories.Ints.Reflection.html#2873" class="Bound">x</a><a id="2929" class="Symbol">)</a>

<a id="checkIdentifier"></a><a id="2932" href="SMT.Theories.Ints.Reflection.html#2932" class="Function">checkIdentifier</a> <a id="2948" class="Symbol">:</a> <a id="2950" class="Symbol">(</a><a id="2951" href="SMT.Theories.Ints.Reflection.html#2951" class="Bound">σ</a> <a id="2953" class="Symbol">:</a> <a id="2955" href="SMT.Theories.Ints.Base.html#812" class="Datatype">Sort</a><a id="2959" class="Symbol">)</a> <a id="2961" class="Symbol">→</a> <a id="2963" href="Agda.Builtin.Reflection.html#489" class="Postulate">Rfl.Name</a> <a id="2972" class="Symbol">→</a> <a id="2974" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="2980" class="Symbol">(</a><a id="2981" href="Data.Product.html#916" class="Function">Σ[</a> <a id="2984" href="SMT.Theories.Ints.Reflection.html#2984" class="Bound">Σ</a> <a id="2986" href="Data.Product.html#916" class="Function">∈</a> <a id="2988" href="SMT.Theory.html#484" class="Record">Signature</a> <a id="2998" href="SMT.Theories.Ints.Reflection.html#2951" class="Bound">σ</a> <a id="3000" href="Data.Product.html#916" class="Function">]</a> <a id="3002" href="SMT.Script.Base.html#1970" class="Function">Macro</a> <a id="3008" href="SMT.Theories.Ints.Reflection.html#2984" class="Bound">Σ</a><a id="3009" class="Symbol">)</a>
<a id="3011" href="SMT.Theories.Ints.Reflection.html#2932" class="Function">checkIdentifier</a> <a id="3027" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a>      <a id="3036" href="SMT.Theories.Ints.Reflection.html#2283" class="InductiveConstructor">`zero</a>   <a id="3044" class="Symbol">=</a> <a id="3046" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="3051" class="Symbol">(</a><a id="3052" href="SMT.Theory.html#719" class="Function">Op₀</a> <a id="3056" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a> <a id="3060" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3062" href="SMT.Theories.Ints.Reflection.html#2422" class="Function">`zero!</a><a id="3068" class="Symbol">)</a>
<a id="3070" href="SMT.Theories.Ints.Reflection.html#2932" class="Function">checkIdentifier</a> <a id="3086" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a>      <a id="3095" href="SMT.Theories.Ints.Reflection.html#2318" class="InductiveConstructor">`suc</a>    <a id="3103" class="Symbol">=</a> <a id="3105" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="3110" class="Symbol">(</a><a id="3111" href="SMT.Theory.html#770" class="Function">Op₁</a> <a id="3115" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a> <a id="3119" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3121" href="SMT.Theories.Ints.Reflection.html#2476" class="Function">`suc!</a><a id="3126" class="Symbol">)</a>
<a id="3128" href="SMT.Theories.Ints.Reflection.html#2932" class="Function">checkIdentifier</a> <a id="3144" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a>      <a id="3153" href="SMT.Theories.Ints.Reflection.html#2616" class="InductiveConstructor Operator">`+_</a>     <a id="3161" class="Symbol">=</a> <a id="3163" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="3168" class="Symbol">(</a><a id="3169" href="SMT.Theory.html#770" class="Function">Op₁</a> <a id="3173" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a> <a id="3177" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3179" href="SMT.Theories.Ints.Reflection.html#2679" class="Function Operator">`+!_</a><a id="3183" class="Symbol">)</a>
<a id="3185" href="SMT.Theories.Ints.Reflection.html#2932" class="Function">checkIdentifier</a> <a id="3201" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a>      <a id="3210" href="SMT.Theories.Ints.Reflection.html#2649" class="InductiveConstructor Operator">`-[1+_]</a> <a id="3218" class="Symbol">=</a> <a id="3220" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="3225" class="Symbol">(</a><a id="3226" href="SMT.Theory.html#770" class="Function">Op₁</a> <a id="3230" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a> <a id="3234" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3236" href="SMT.Theories.Ints.Reflection.html#2724" class="Function Operator">`-[1+_]!</a><a id="3244" class="Symbol">)</a>
<a id="3246" href="SMT.Theories.Ints.Reflection.html#2932" class="Function">checkIdentifier</a> <a id="3262" href="SMT.Theories.Ints.Base.html#1027" class="InductiveConstructor">BOOL</a>     <a id="3271" href="SMT.Theories.Ints.Reflection.html#1423" class="InductiveConstructor">`eq</a>     <a id="3279" class="Symbol">=</a> <a id="3281" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="3286" class="Symbol">(</a><a id="3287" href="SMT.Theories.Core.Extensions.html#478" class="Function">Rel</a> <a id="3291" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a> <a id="3295" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3297" href="SMT.Script.Base.html#1686" class="InductiveConstructor">app</a> <a id="3301" href="SMT.Theories.Ints.Base.html#3510" class="InductiveConstructor">eq</a><a id="3303" class="Symbol">)</a>
<a id="3305" href="SMT.Theories.Ints.Reflection.html#2932" class="Function">checkIdentifier</a> <a id="3321" href="SMT.Theories.Ints.Base.html#1027" class="InductiveConstructor">BOOL</a>     <a id="3330" href="SMT.Theories.Ints.Reflection.html#1460" class="InductiveConstructor">`neq</a>    <a id="3338" class="Symbol">=</a> <a id="3340" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="3345" class="Symbol">(</a><a id="3346" href="SMT.Theories.Core.Extensions.html#478" class="Function">Rel</a> <a id="3350" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a> <a id="3354" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3356" href="SMT.Script.Base.html#1686" class="InductiveConstructor">app</a> <a id="3360" href="SMT.Theories.Ints.Base.html#3540" class="InductiveConstructor">neq</a><a id="3363" class="Symbol">)</a>
<a id="3365" href="SMT.Theories.Ints.Reflection.html#2932" class="Function">checkIdentifier</a> <a id="3381" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a>      <a id="3390" href="SMT.Theories.Ints.Reflection.html#1714" class="InductiveConstructor">`neg</a>    <a id="3398" class="Symbol">=</a> <a id="3400" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="3405" class="Symbol">(</a><a id="3406" href="SMT.Theory.html#770" class="Function">Op₁</a> <a id="3410" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a> <a id="3414" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3416" href="SMT.Script.Base.html#1686" class="InductiveConstructor">app</a> <a id="3420" href="SMT.Theories.Ints.Base.html#3615" class="InductiveConstructor">neg</a><a id="3423" class="Symbol">)</a>
<a id="3425" href="SMT.Theories.Ints.Reflection.html#2932" class="Function">checkIdentifier</a> <a id="3441" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a>      <a id="3450" href="SMT.Theories.Ints.Reflection.html#1747" class="InductiveConstructor">`sub</a>    <a id="3458" class="Symbol">=</a> <a id="3460" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="3465" class="Symbol">(</a><a id="3466" href="SMT.Theory.html#825" class="Function">Op₂</a> <a id="3470" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a> <a id="3474" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3476" href="SMT.Script.Base.html#1686" class="InductiveConstructor">app</a> <a id="3480" href="SMT.Theories.Ints.Base.html#3645" class="InductiveConstructor">sub</a><a id="3483" class="Symbol">)</a>
<a id="3485" href="SMT.Theories.Ints.Reflection.html#2932" class="Function">checkIdentifier</a> <a id="3501" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a>      <a id="3510" href="SMT.Theories.Ints.Reflection.html#1781" class="InductiveConstructor">`add</a>    <a id="3518" class="Symbol">=</a> <a id="3520" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="3525" class="Symbol">(</a><a id="3526" href="SMT.Theory.html#825" class="Function">Op₂</a> <a id="3530" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a> <a id="3534" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3536" href="SMT.Script.Base.html#1686" class="InductiveConstructor">app</a> <a id="3540" href="SMT.Theories.Ints.Base.html#3675" class="InductiveConstructor">add</a><a id="3543" class="Symbol">)</a>
<a id="3545" href="SMT.Theories.Ints.Reflection.html#2932" class="Function">checkIdentifier</a> <a id="3561" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a>      <a id="3570" href="SMT.Theories.Ints.Reflection.html#1815" class="InductiveConstructor">`mul</a>    <a id="3578" class="Symbol">=</a> <a id="3580" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="3585" class="Symbol">(</a><a id="3586" href="SMT.Theory.html#825" class="Function">Op₂</a> <a id="3590" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a> <a id="3594" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3596" href="SMT.Script.Base.html#1686" class="InductiveConstructor">app</a> <a id="3600" href="SMT.Theories.Ints.Base.html#3705" class="InductiveConstructor">mul</a><a id="3603" class="Symbol">)</a>
<a id="3605" href="SMT.Theories.Ints.Reflection.html#2932" class="Function">checkIdentifier</a> <a id="3621" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a>      <a id="3630" href="SMT.Theories.Ints.Reflection.html#2112" class="InductiveConstructor">`abs</a>    <a id="3638" class="Symbol">=</a> <a id="3640" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="3645" class="Symbol">(</a><a id="3646" href="SMT.Theory.html#770" class="Function">Op₁</a> <a id="3650" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a> <a id="3654" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3656" href="SMT.Script.Base.html#1686" class="InductiveConstructor">app</a> <a id="3660" href="SMT.Theories.Ints.Base.html#3795" class="InductiveConstructor">abs</a><a id="3663" class="Symbol">)</a>
<a id="3665" href="SMT.Theories.Ints.Reflection.html#2932" class="Function">checkIdentifier</a> <a id="3681" href="SMT.Theories.Ints.Base.html#1027" class="InductiveConstructor">BOOL</a>     <a id="3690" href="SMT.Theories.Ints.Reflection.html#2146" class="InductiveConstructor">`leq</a>    <a id="3698" class="Symbol">=</a> <a id="3700" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="3705" class="Symbol">(</a><a id="3706" href="SMT.Theories.Core.Extensions.html#478" class="Function">Rel</a> <a id="3710" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a> <a id="3714" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3716" href="SMT.Script.Base.html#1686" class="InductiveConstructor">app</a> <a id="3720" href="SMT.Theories.Ints.Base.html#3825" class="InductiveConstructor">leq</a><a id="3723" class="Symbol">)</a>
<a id="3725" href="SMT.Theories.Ints.Reflection.html#2932" class="Function">checkIdentifier</a> <a id="3741" href="SMT.Theories.Ints.Base.html#1027" class="InductiveConstructor">BOOL</a>     <a id="3750" href="SMT.Theories.Ints.Reflection.html#2180" class="InductiveConstructor">`lt</a>     <a id="3758" class="Symbol">=</a> <a id="3760" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="3765" class="Symbol">(</a><a id="3766" href="SMT.Theories.Core.Extensions.html#478" class="Function">Rel</a> <a id="3770" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a> <a id="3774" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3776" href="SMT.Script.Base.html#1686" class="InductiveConstructor">app</a> <a id="3780" href="SMT.Theories.Ints.Base.html#3855" class="InductiveConstructor">lt</a><a id="3782" class="Symbol">)</a>
<a id="3784" href="SMT.Theories.Ints.Reflection.html#2932" class="Function">checkIdentifier</a> <a id="3800" href="SMT.Theories.Ints.Base.html#1027" class="InductiveConstructor">BOOL</a>     <a id="3809" href="SMT.Theories.Ints.Reflection.html#2214" class="InductiveConstructor">`geq</a>    <a id="3817" class="Symbol">=</a> <a id="3819" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="3824" class="Symbol">(</a><a id="3825" href="SMT.Theories.Core.Extensions.html#478" class="Function">Rel</a> <a id="3829" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a> <a id="3833" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3835" href="SMT.Script.Base.html#1686" class="InductiveConstructor">app</a> <a id="3839" href="SMT.Theories.Ints.Base.html#3885" class="InductiveConstructor">geq</a><a id="3842" class="Symbol">)</a>
<a id="3844" href="SMT.Theories.Ints.Reflection.html#2932" class="Function">checkIdentifier</a> <a id="3860" href="SMT.Theories.Ints.Base.html#1027" class="InductiveConstructor">BOOL</a>     <a id="3869" href="SMT.Theories.Ints.Reflection.html#2248" class="InductiveConstructor">`gt</a>     <a id="3877" class="Symbol">=</a> <a id="3879" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="3884" class="Symbol">(</a><a id="3885" href="SMT.Theories.Core.Extensions.html#478" class="Function">Rel</a> <a id="3889" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a> <a id="3893" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3895" href="SMT.Script.Base.html#1686" class="InductiveConstructor">app</a> <a id="3899" href="SMT.Theories.Ints.Base.html#3915" class="InductiveConstructor">gt</a><a id="3901" class="Symbol">)</a>
<a id="3903" href="SMT.Theories.Ints.Reflection.html#2932" class="Function">checkIdentifier</a> <a id="3919" href="SMT.Theories.Ints.Base.html#864" class="InductiveConstructor">INT</a>       <a id="3929" class="Symbol">_</a>      <a id="3936" class="Symbol">=</a> <a id="3938" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>
<a id="3946" href="SMT.Theories.Ints.Reflection.html#2932" class="CatchallClause Function">checkIdentifier</a><a id="3961" class="CatchallClause"> </a><a id="3962" class="CatchallClause Symbol">(</a><a id="3963" href="SMT.Theories.Ints.Base.html#832" class="CatchallClause InductiveConstructor">CORE</a><a id="3967" class="CatchallClause"> </a><a id="3968" href="SMT.Theories.Ints.Reflection.html#3968" class="CatchallClause Bound">φ</a><a id="3969" class="CatchallClause Symbol">)</a><a id="3970" class="CatchallClause">  </a><a id="3972" href="SMT.Theories.Ints.Reflection.html#3972" class="CatchallClause Bound">x</a>      <a id="3979" class="Symbol">=</a>
  <a id="3983" href="Data.Maybe.Base.html#2020" class="Function">Maybe.map</a> <a id="3993" class="Symbol">(</a><a id="3994" href="Data.Product.html#2450" class="Function">Prod.map</a> <a id="4003" href="SMT.Theories.Core.Extensions.html#642" class="Function">liftCoreSignature</a> <a id="4021" class="Symbol">(λ</a> <a id="4024" href="SMT.Theories.Ints.Reflection.html#4024" class="Bound">i</a> <a id="4026" class="Symbol">→</a> <a id="4028" href="SMT.Script.Base.html#1686" class="InductiveConstructor">app</a> <a id="4032" class="Symbol">(</a><a id="4033" href="SMT.Theories.Ints.Base.html#3458" class="InductiveConstructor">core</a> <a id="4038" href="SMT.Theories.Ints.Reflection.html#4024" class="Bound">i</a><a id="4039" class="Symbol">)))</a> <a id="4043" class="Symbol">(</a><a id="4044" href="SMT.Theories.Core.Reflection.html#1929" class="Function">checkCoreIdentifier′</a> <a id="4065" href="SMT.Theories.Ints.Reflection.html#3968" class="Bound">φ</a> <a id="4067" href="SMT.Theories.Ints.Reflection.html#3972" class="Bound">x</a><a id="4068" class="Symbol">)</a>


<a id="4072" class="Comment">---------------</a>
<a id="4088" class="Comment">-- Instances --</a>
<a id="4104" class="Comment">---------------</a>

<a id="reflectable"></a><a id="4121" href="SMT.Theories.Ints.Reflection.html#4121" class="Function">reflectable</a> <a id="4133" class="Symbol">:</a> <a id="4135" href="SMT.Theory.Reflection.html#338" class="Record">Reflectable</a> <a id="4147" href="SMT.Theories.Ints.Base.html#5354" class="Function">theory</a>
<a id="4154" href="SMT.Theory.Reflection.html#374" class="Field">Reflectable.sorts</a>           <a id="4182" href="SMT.Theories.Ints.Reflection.html#4121" class="Function">reflectable</a> <a id="4194" class="Symbol">=</a> <a id="4196" href="SMT.Theories.Ints.Reflection.html#834" class="Function">sorts</a>
<a id="4202" href="SMT.Theory.Reflection.html#406" class="Field">Reflectable.checkSort</a>       <a id="4230" href="SMT.Theories.Ints.Reflection.html#4121" class="Function">reflectable</a> <a id="4242" class="Symbol">=</a> <a id="4244" href="SMT.Theories.Ints.Reflection.html#892" class="Function">checkSort</a>
<a id="4254" href="SMT.Theory.Reflection.html#450" class="Field">Reflectable.checkLiteral</a>    <a id="4282" href="SMT.Theories.Ints.Reflection.html#4121" class="Function">reflectable</a> <a id="4294" class="Symbol">=</a> <a id="4296" href="SMT.Theories.Ints.Reflection.html#1127" class="Function">checkLiteral</a>
<a id="4309" href="SMT.Theory.Reflection.html#517" class="Field">Reflectable.checkIdentifier</a> <a id="4337" href="SMT.Theories.Ints.Reflection.html#4121" class="Function">reflectable</a> <a id="4349" class="Symbol">=</a> <a id="4351" href="SMT.Theories.Ints.Reflection.html#2932" class="Function">checkIdentifier</a>
</pre></body></html>
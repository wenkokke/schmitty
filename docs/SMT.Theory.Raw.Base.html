<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>SMT.Theory.Raw.Base</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--guardedness</a> <a id="27" class="Symbol">#-}</a>

<a id="32" class="Comment">--------------------------------------------------------------------------------</a>
<a id="113" class="Comment">-- Schmitty the Solver</a>
<a id="136" class="Comment">--</a>
<a id="139" class="Comment">-- This module contains the definition of the raw theory, whose identifiers are</a>
<a id="219" class="Comment">-- reflected Agda names and whose literals are reflected Agda literals. The raw</a>
<a id="299" class="Comment">-- theory does not correspond to any SMT-LIB theory. Instead, it is intended as</a>
<a id="379" class="Comment">-- an intermediate language between reflected Agda syntax and the various</a>
<a id="453" class="Comment">-- SMT-LIB theories.</a>
<a id="474" class="Comment">--</a>
<a id="477" class="Comment">-- This module re-exports the basic definitions from `SMT.Script.Base`, with the</a>
<a id="558" class="Comment">-- type names prefixed with `Raw` and the symbols suffixed with `ᵣ`, e.g.,</a>
<a id="633" class="Comment">-- `RawScript` and `varᵣ`.</a>
<a id="660" class="Comment">--------------------------------------------------------------------------------</a>

<a id="742" class="Keyword">module</a> <a id="749" href="SMT.Theory.Raw.Base.html" class="Module">SMT.Theory.Raw.Base</a> <a id="769" class="Keyword">where</a>

<a id="776" class="Keyword">open</a> <a id="781" class="Keyword">import</a> <a id="788" href="Data.Empty.html" class="Module">Data.Empty</a> <a id="799" class="Symbol">as</a> <a id="802" class="Module">Empty</a> <a id="808" class="Keyword">using</a> <a id="814" class="Symbol">(</a><a id="815" href="Data.Empty.html#526" class="Datatype">⊥</a><a id="816" class="Symbol">;</a> <a id="818" href="Data.Empty.html#628" class="Function">⊥-elim</a><a id="824" class="Symbol">)</a>
<a id="826" class="Keyword">open</a> <a id="831" class="Keyword">import</a> <a id="838" href="Data.Environment.html" class="Module">Data.Environment</a> <a id="855" class="Symbol">as</a> <a id="858" class="Module">Env</a> <a id="862" class="Keyword">using</a> <a id="868" class="Symbol">(</a><a id="869" href="Data.Environment.html#360" class="Datatype">Env</a><a id="872" class="Symbol">;</a> <a id="874" href="Data.Environment.html#410" class="InductiveConstructor">[]</a><a id="876" class="Symbol">;</a> <a id="878" href="Data.Environment.html#427" class="InductiveConstructor Operator">_∷_</a><a id="881" class="Symbol">)</a>
<a id="883" class="Keyword">open</a> <a id="888" class="Keyword">import</a> <a id="895" href="Data.Maybe.html" class="Module">Data.Maybe</a> <a id="906" class="Symbol">as</a> <a id="909" class="Module">Maybe</a> <a id="915" class="Keyword">using</a> <a id="921" class="Symbol">(</a><a id="922" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a><a id="927" class="Symbol">;</a> <a id="929" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a><a id="933" class="Symbol">;</a> <a id="935" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a><a id="942" class="Symbol">)</a>
<a id="944" class="Keyword">open</a> <a id="949" class="Keyword">import</a> <a id="956" href="Data.List.html" class="Module">Data.List</a> <a id="966" class="Symbol">as</a> <a id="969" class="Module">List</a> <a id="974" class="Keyword">using</a> <a id="980" class="Symbol">(</a><a id="981" href="Agda.Builtin.List.html#148" class="Datatype">List</a><a id="985" class="Symbol">;</a> <a id="987" href="Data.List.Base.html#10383" class="InductiveConstructor">[]</a><a id="989" class="Symbol">;</a> <a id="991" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">_∷_</a><a id="994" class="Symbol">)</a>
<a id="996" class="Keyword">open</a> <a id="1001" class="Keyword">import</a> <a id="1008" href="Data.Product.html" class="Module">Data.Product</a> <a id="1021" class="Symbol">as</a> <a id="1024" class="Module">Prod</a> <a id="1029" class="Keyword">using</a> <a id="1035" class="Symbol">(</a><a id="1036" href="Data.Product.html#1167" class="Function Operator">_×_</a><a id="1039" class="Symbol">;</a> <a id="1041" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a><a id="1044" class="Symbol">;</a> <a id="1046" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a><a id="1051" class="Symbol">;</a> <a id="1053" href="Agda.Builtin.Sigma.html#264" class="Field">proj₂</a><a id="1058" class="Symbol">)</a>
<a id="1060" class="Keyword">open</a> <a id="1065" class="Keyword">import</a> <a id="1072" href="Data.String.html" class="Module">Data.String</a> <a id="1084" class="Symbol">as</a> <a id="1087" class="Module">String</a> <a id="1094" class="Keyword">using</a> <a id="1100" class="Symbol">(</a><a id="1101" href="Agda.Builtin.String.html#336" class="Postulate">String</a><a id="1107" class="Symbol">)</a>
<a id="1109" class="Keyword">open</a> <a id="1114" class="Keyword">import</a> <a id="1121" href="Function.html" class="Module">Function</a> <a id="1130" class="Keyword">using</a> <a id="1136" class="Symbol">(</a><a id="1137" href="Function.Base.html#615" class="Function">id</a><a id="1139" class="Symbol">)</a>
<a id="1141" class="Keyword">open</a> <a id="1146" class="Keyword">import</a> <a id="1153" href="Function.Equivalence.html" class="Module">Function.Equivalence</a> <a id="1174" class="Keyword">using</a> <a id="1180" class="Symbol">(</a><a id="1181" href="Function.Equivalence.html#1297" class="Function">equivalence</a><a id="1192" class="Symbol">)</a>
<a id="1194" class="Keyword">import</a> <a id="1201" href="Reflection.html" class="Module">Reflection</a> <a id="1212" class="Symbol">as</a> <a id="1215" class="Module">Rfl</a>
<a id="1219" class="Keyword">open</a> <a id="1224" class="Keyword">import</a> <a id="1231" href="Reflection.Term.html" class="Module">Reflection.Term</a> <a id="1247" class="Keyword">using</a> <a id="1253" class="Symbol">()</a> <a id="1256" class="Keyword">renaming</a> <a id="1265" class="Symbol">(</a><a id="1266" href="Reflection.Term.html#4484" class="Function Operator">_≟_</a> <a id="1270" class="Symbol">to</a> <a id="1273" class="Function Operator">_≟-Term_</a><a id="1281" class="Symbol">)</a>
<a id="1283" class="Keyword">open</a> <a id="1288" class="Keyword">import</a> <a id="1295" href="Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="1312" class="Keyword">using</a> <a id="1318" class="Symbol">(</a><a id="1319" href="Relation.Nullary.html#1511" class="Record">Dec</a><a id="1322" class="Symbol">;</a> <a id="1324" href="Relation.Nullary.html#1648" class="InductiveConstructor">yes</a><a id="1327" class="Symbol">;</a> <a id="1329" href="Relation.Nullary.html#1685" class="InductiveConstructor">no</a><a id="1331" class="Symbol">)</a>
<a id="1333" class="Keyword">import</a> <a id="1340" href="Relation.Nullary.Decidable.html" class="Module">Relation.Nullary.Decidable</a> <a id="1367" class="Symbol">as</a> <a id="1370" class="Module">Dec</a>
<a id="1374" class="Keyword">open</a> <a id="1379" class="Keyword">import</a> <a id="1386" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="1424" class="Keyword">using</a> <a id="1430" class="Symbol">(</a><a id="1431" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="1434" class="Symbol">;</a> <a id="1436" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="1440" class="Symbol">;</a> <a id="1442" href="Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a><a id="1446" class="Symbol">)</a>
<a id="1448" class="Keyword">open</a> <a id="1453" class="Keyword">import</a> <a id="1460" href="SMT.Theory.Base.html" class="Module">SMT.Theory.Base</a>
<a id="1476" class="Keyword">open</a> <a id="1481" class="Keyword">import</a> <a id="1488" href="SMT.Theory.Class.Parsable.html" class="Module">SMT.Theory.Class.Parsable</a>
<a id="1514" class="Keyword">open</a> <a id="1519" class="Keyword">import</a> <a id="1526" href="SMT.Theory.Class.Printable.html" class="Module">SMT.Theory.Class.Printable</a>
<a id="1553" class="Keyword">open</a> <a id="1558" class="Keyword">import</a> <a id="1565" href="SMT.Theory.Class.Solvable.html" class="Module">SMT.Theory.Class.Solvable</a>
<a id="1591" class="Keyword">open</a> <a id="1596" class="Keyword">import</a> <a id="1603" href="Text.Parser.String.html" class="Module">Text.Parser.String</a>

<a id="1623" class="Keyword">data</a> <a id="RawSort"></a><a id="1628" href="SMT.Theory.Raw.Base.html#1628" class="Datatype">RawSort</a> <a id="1636" class="Symbol">:</a> <a id="1638" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="1642" class="Keyword">where</a>
  <a id="RawSort.⋆"></a><a id="1650" href="SMT.Theory.Raw.Base.html#1650" class="InductiveConstructor">⋆</a>    <a id="1655" class="Symbol">:</a> <a id="1657" href="SMT.Theory.Raw.Base.html#1628" class="Datatype">RawSort</a>
  <a id="RawSort.TERM"></a><a id="1667" href="SMT.Theory.Raw.Base.html#1667" class="InductiveConstructor">TERM</a> <a id="1672" class="Symbol">:</a> <a id="1674" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Rfl.Term</a> <a id="1683" class="Symbol">→</a> <a id="1685" href="SMT.Theory.Raw.Base.html#1628" class="Datatype">RawSort</a>

<a id="TERM-injective"></a><a id="1694" href="SMT.Theory.Raw.Base.html#1694" class="Function">TERM-injective</a> <a id="1709" class="Symbol">:</a> <a id="1711" class="Symbol">∀</a> <a id="1713" class="Symbol">{</a><a id="1714" href="SMT.Theory.Raw.Base.html#1714" class="Bound">t</a> <a id="1716" href="SMT.Theory.Raw.Base.html#1716" class="Bound">t′</a><a id="1718" class="Symbol">}</a> <a id="1720" class="Symbol">→</a> <a id="1722" href="SMT.Theory.Raw.Base.html#1667" class="InductiveConstructor">TERM</a> <a id="1727" href="SMT.Theory.Raw.Base.html#1714" class="Bound">t</a> <a id="1729" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="1731" href="SMT.Theory.Raw.Base.html#1667" class="InductiveConstructor">TERM</a> <a id="1736" href="SMT.Theory.Raw.Base.html#1716" class="Bound">t′</a> <a id="1739" class="Symbol">→</a> <a id="1741" href="SMT.Theory.Raw.Base.html#1714" class="Bound">t</a> <a id="1743" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="1745" href="SMT.Theory.Raw.Base.html#1716" class="Bound">t′</a>
<a id="1748" href="SMT.Theory.Raw.Base.html#1694" class="Function">TERM-injective</a> <a id="1763" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="1768" class="Symbol">=</a> <a id="1770" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>

<a id="_≟-RawSort_"></a><a id="1776" href="SMT.Theory.Raw.Base.html#1776" class="Function Operator">_≟-RawSort_</a> <a id="1788" class="Symbol">:</a> <a id="1790" class="Symbol">(</a><a id="1791" href="SMT.Theory.Raw.Base.html#1791" class="Bound">σ</a> <a id="1793" href="SMT.Theory.Raw.Base.html#1793" class="Bound">σ′</a> <a id="1796" class="Symbol">:</a> <a id="1798" href="SMT.Theory.Raw.Base.html#1628" class="Datatype">RawSort</a><a id="1805" class="Symbol">)</a> <a id="1807" class="Symbol">→</a> <a id="1809" href="Relation.Nullary.html#1511" class="Record">Dec</a> <a id="1813" class="Symbol">(</a><a id="1814" href="SMT.Theory.Raw.Base.html#1791" class="Bound">σ</a> <a id="1816" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="1818" href="SMT.Theory.Raw.Base.html#1793" class="Bound">σ′</a><a id="1820" class="Symbol">)</a>
<a id="1822" href="SMT.Theory.Raw.Base.html#1650" class="InductiveConstructor">⋆</a>      <a id="1829" href="SMT.Theory.Raw.Base.html#1776" class="Function Operator">≟-RawSort</a> <a id="1839" href="SMT.Theory.Raw.Base.html#1650" class="InductiveConstructor">⋆</a>       <a id="1847" class="Symbol">=</a> <a id="1849" href="Relation.Nullary.html#1648" class="InductiveConstructor">yes</a> <a id="1853" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a>
<a id="1858" href="SMT.Theory.Raw.Base.html#1650" class="InductiveConstructor">⋆</a>      <a id="1865" href="SMT.Theory.Raw.Base.html#1776" class="Function Operator">≟-RawSort</a> <a id="1875" href="SMT.Theory.Raw.Base.html#1667" class="InductiveConstructor">TERM</a> <a id="1880" class="Symbol">_</a>  <a id="1883" class="Symbol">=</a> <a id="1885" href="Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="1888" class="Symbol">λ()</a>
<a id="1892" href="SMT.Theory.Raw.Base.html#1667" class="InductiveConstructor">TERM</a> <a id="1897" href="SMT.Theory.Raw.Base.html#1897" class="Bound">x</a> <a id="1899" href="SMT.Theory.Raw.Base.html#1776" class="Function Operator">≟-RawSort</a> <a id="1909" href="SMT.Theory.Raw.Base.html#1650" class="InductiveConstructor">⋆</a>       <a id="1917" class="Symbol">=</a> <a id="1919" href="Relation.Nullary.html#1685" class="InductiveConstructor">no</a> <a id="1922" class="Symbol">λ()</a>
<a id="1926" href="SMT.Theory.Raw.Base.html#1667" class="InductiveConstructor">TERM</a> <a id="1931" href="SMT.Theory.Raw.Base.html#1931" class="Bound">t</a> <a id="1933" href="SMT.Theory.Raw.Base.html#1776" class="Function Operator">≟-RawSort</a> <a id="1943" href="SMT.Theory.Raw.Base.html#1667" class="InductiveConstructor">TERM</a> <a id="1948" href="SMT.Theory.Raw.Base.html#1948" class="Bound">t′</a> <a id="1951" class="Symbol">=</a> <a id="1953" href="Relation.Nullary.Decidable.html#1228" class="Function">Dec.map</a> <a id="1961" class="Symbol">(</a><a id="1962" href="Function.Equivalence.html#1297" class="Function">equivalence</a> <a id="1974" class="Symbol">(</a><a id="1975" href="Relation.Binary.PropositionalEquality.Core.html#1130" class="Function">cong</a> <a id="1980" href="SMT.Theory.Raw.Base.html#1667" class="InductiveConstructor">TERM</a><a id="1984" class="Symbol">)</a> <a id="1986" href="SMT.Theory.Raw.Base.html#1694" class="Function">TERM-injective</a><a id="2000" class="Symbol">)</a> <a id="2002" class="Symbol">(</a><a id="2003" href="SMT.Theory.Raw.Base.html#1931" class="Bound">t</a> <a id="2005" href="SMT.Theory.Raw.Base.html#1273" class="Function Operator">≟-Term</a> <a id="2012" href="SMT.Theory.Raw.Base.html#1948" class="Bound">t′</a><a id="2014" class="Symbol">)</a>

<a id="rawTheory"></a><a id="2017" href="SMT.Theory.Raw.Base.html#2017" class="Function">rawTheory</a> <a id="2027" class="Symbol">:</a> <a id="2029" href="SMT.Theory.Base.html#1730" class="Record">Theory</a>
<a id="2036" href="SMT.Theory.Base.html#1762" class="Field">Theory.Sort</a>        <a id="2055" href="SMT.Theory.Raw.Base.html#2017" class="Function">rawTheory</a> <a id="2065" class="Symbol">=</a> <a id="2067" href="SMT.Theory.Raw.Base.html#1628" class="Datatype">RawSort</a>
<a id="2075" href="SMT.Theory.Base.html#1786" class="Field Operator">Theory._≟-Sort_</a>    <a id="2094" href="SMT.Theory.Raw.Base.html#2017" class="Function">rawTheory</a> <a id="2104" class="Symbol">=</a> <a id="2106" href="SMT.Theory.Raw.Base.html#1776" class="Function Operator">_≟-RawSort_</a>
<a id="2118" href="SMT.Theory.Base.html#1835" class="Field">Theory.BOOL</a>        <a id="2137" href="SMT.Theory.Raw.Base.html#2017" class="Function">rawTheory</a> <a id="2147" class="Symbol">=</a> <a id="2149" href="SMT.Theory.Raw.Base.html#1650" class="InductiveConstructor">⋆</a>
<a id="2151" href="SMT.Theory.Base.html#2506" class="Field">Theory.Value</a>       <a id="2170" href="SMT.Theory.Raw.Base.html#2017" class="Function">rawTheory</a> <a id="2180" class="Symbol">=</a> <a id="2182" class="Symbol">λ</a> <a id="2184" href="SMT.Theory.Raw.Base.html#2184" class="Bound">_</a> <a id="2186" class="Symbol">→</a> <a id="2188" href="Data.Empty.html#526" class="Datatype">⊥</a>
<a id="2190" href="SMT.Theory.Base.html#1860" class="Field">Theory.Literal</a>     <a id="2209" href="SMT.Theory.Raw.Base.html#2017" class="Function">rawTheory</a> <a id="2219" class="Symbol">=</a> <a id="2221" class="Symbol">λ</a> <a id="2223" href="SMT.Theory.Raw.Base.html#2223" class="Bound">_</a> <a id="2225" class="Symbol">→</a> <a id="2227" href="Agda.Builtin.Reflection.html#4092" class="Datatype">Rfl.Literal</a>
<a id="2239" href="SMT.Theory.Base.html#1891" class="Field">Theory.Identifier</a>  <a id="2258" href="SMT.Theory.Raw.Base.html#2017" class="Function">rawTheory</a> <a id="2268" class="Symbol">=</a> <a id="2270" class="Symbol">λ</a> <a id="2272" href="SMT.Theory.Raw.Base.html#2272" class="Bound">_</a> <a id="2274" class="Symbol">→</a> <a id="2276" href="Agda.Builtin.Reflection.html#489" class="Postulate">Rfl.Name</a>
<a id="2285" href="SMT.Theory.Base.html#1942" class="Field">Theory.quoteSort</a>   <a id="2304" href="SMT.Theory.Raw.Base.html#2017" class="Function">rawTheory</a> <a id="2314" class="Symbol">=</a> <a id="2316" class="Symbol">λ</a> <a id="2318" href="SMT.Theory.Raw.Base.html#2318" class="Bound">_</a> <a id="2320" class="Symbol">→</a> <a id="2322" href="Agda.Builtin.Reflection.html#4846" class="InductiveConstructor">Rfl.con</a> <a id="2330" class="Symbol">(</a><a id="2331" class="Keyword">quote</a> <a id="2337" href="SMT.Theory.Raw.Base.html#1650" class="InductiveConstructor">⋆</a><a id="2338" class="Symbol">)</a> <a id="2340" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>
<a id="2343" href="SMT.Theory.Base.html#2535" class="Field">Theory.quoteValue</a>  <a id="2362" href="SMT.Theory.Raw.Base.html#2017" class="Function">rawTheory</a> <a id="2372" class="Symbol">=</a> <a id="2374" class="Symbol">λ</a> <a id="2376" href="SMT.Theory.Raw.Base.html#2376" class="Bound">_</a> <a id="2378" class="Symbol">→</a> <a id="2380" href="Data.Empty.html#628" class="Function">⊥-elim</a>
<a id="2387" href="SMT.Theory.Base.html#2585" class="Field">Theory.interpValue</a> <a id="2406" href="SMT.Theory.Raw.Base.html#2017" class="Function">rawTheory</a> <a id="2416" class="Symbol">=</a> <a id="2418" class="Symbol">λ</a> <a id="2420" href="SMT.Theory.Raw.Base.html#2420" class="Bound">t</a> <a id="2422" class="Symbol">→</a> <a id="2424" href="SMT.Theory.Raw.Base.html#2420" class="Bound">t</a>

<a id="2427" class="Keyword">instance</a>
  <a id="rawPrintable"></a><a id="2438" href="SMT.Theory.Raw.Base.html#2438" class="Function">rawPrintable</a> <a id="2451" class="Symbol">:</a> <a id="2453" href="SMT.Theory.Class.Printable.html#664" class="Record">Printable</a> <a id="2463" href="SMT.Theory.Raw.Base.html#2017" class="Function">rawTheory</a>
  <a id="2475" href="SMT.Theory.Class.Printable.html#737" class="Field">Printable.showSort</a>       <a id="2500" href="SMT.Theory.Raw.Base.html#2438" class="Function">rawPrintable</a> <a id="2513" class="Symbol">=</a> <a id="2515" class="Symbol">λ</a> <a id="2517" href="SMT.Theory.Raw.Base.html#2517" class="Bound">_</a> <a id="2519" class="Symbol">→</a> <a id="2521" class="String">&quot;⋆&quot;</a>
  <a id="2527" href="SMT.Theory.Class.Printable.html#772" class="Field">Printable.showLiteral</a>    <a id="2552" href="SMT.Theory.Raw.Base.html#2438" class="Function">rawPrintable</a> <a id="2565" class="Symbol">=</a> <a id="2567" href="Reflection.Show.html#1804" class="Function">Rfl.showLiteral</a>
  <a id="2585" href="SMT.Theory.Class.Printable.html#825" class="Field">Printable.showIdentifier</a> <a id="2610" href="SMT.Theory.Raw.Base.html#2438" class="Function">rawPrintable</a> <a id="2623" class="Symbol">=</a> <a id="2625" href="Agda.Builtin.Reflection.html#622" class="Primitive">Rfl.showName</a>

  <a id="rawParsable"></a><a id="2641" href="SMT.Theory.Raw.Base.html#2641" class="Function">rawParsable</a> <a id="2653" class="Symbol">:</a> <a id="2655" href="SMT.Theory.Class.Parsable.html#452" class="Record">Parsable</a> <a id="2664" href="SMT.Theory.Raw.Base.html#2017" class="Function">rawTheory</a>
  <a id="2676" href="SMT.Theory.Class.Parsable.html#525" class="Field">Parsable.parseSort</a>  <a id="2696" href="SMT.Theory.Raw.Base.html#2641" class="Function">rawParsable</a> <a id="2708" class="Symbol">=</a> <a id="2710" href="SMT.Theory.Raw.Base.html#1650" class="InductiveConstructor">⋆</a> <a id="2712" href="Text.Parser.html#4502" class="Function Operator">&lt;$</a> <a id="2715" href="Text.Parser.String.html#496" class="Function">lexeme</a> <a id="2722" class="String">&quot;⋆&quot;</a>
  <a id="2728" href="SMT.Theory.Class.Parsable.html#559" class="Field">Parsable.parseValue</a> <a id="2748" href="SMT.Theory.Raw.Base.html#2641" class="Function">rawParsable</a> <a id="2760" class="Symbol">=</a> <a id="2762" class="Symbol">λ</a> <a id="2764" href="SMT.Theory.Raw.Base.html#2764" class="Bound">_</a> <a id="2766" class="Symbol">→</a> <a id="2768" href="Text.Parser.html#3882" class="Function">fail</a>

  <a id="rawSolvable"></a><a id="2776" href="SMT.Theory.Raw.Base.html#2776" class="Function">rawSolvable</a> <a id="2788" class="Symbol">:</a> <a id="2790" href="SMT.Theory.Class.Solvable.html#1752" class="Record">Solvable</a> <a id="2799" href="SMT.Theory.Raw.Base.html#2017" class="Function">rawTheory</a>
  <a id="2811" href="SMT.Theory.Raw.Base.html#2776" class="Function">rawSolvable</a> <a id="2823" class="Symbol">=</a> <a id="2825" href="SMT.Theory.Class.Solvable.html#2053" class="Function">makeSolvable</a> <a id="2838" href="SMT.Theory.Raw.Base.html#2017" class="Function">rawTheory</a>


<a id="2850" class="Comment">-- Export basic constructs from SMT.Script.Base, renamed to use &#39;Raw&#39; whenever</a>
<a id="2929" class="Comment">-- conflicts with other theories are possible.</a>
<a id="2976" class="Keyword">open</a> <a id="2981" class="Keyword">import</a> <a id="2988" href="SMT.Script.Base.html" class="Module">SMT.Script.Base</a> <a id="3004" href="SMT.Theory.Raw.Base.html#2017" class="Function">rawTheory</a> <a id="3014" class="Keyword">public</a>
  <a id="3023" class="Keyword">using</a> <a id="3029" class="Symbol">()</a>
  <a id="3034" class="Keyword">renaming</a> <a id="3043" class="Symbol">(</a> <a id="3045" href="SMT.Script.Base.html#5523" class="Datatype">OutputType</a>      <a id="3061" class="Symbol">to</a> <a id="3064" class="Datatype">RawOutputType</a>
           <a id="3089" class="Symbol">;</a> <a id="3091" href="SMT.Script.Base.html#5617" class="Function">OutputCtxt</a>      <a id="3107" class="Symbol">to</a> <a id="3110" class="Function">RawOutputCtxt</a>
           <a id="3135" class="Symbol">;</a> <a id="3137" href="SMT.Script.Base.html#2388" class="Function">Ctxt</a>            <a id="3153" class="Symbol">to</a> <a id="3156" class="Function">RawCtxt</a>
           <a id="3175" class="Symbol">;</a> <a id="3177" href="SMT.Script.Base.html#2611" class="Function Operator">_∋_</a>             <a id="3193" class="Symbol">to</a> <a id="3196" class="Function Operator">_∋ᵣ_</a>
           <a id="3212" class="Symbol">;</a> <a id="3214" href="SMT.Script.Base.html#3141" class="Datatype">Term</a>            <a id="3230" class="Symbol">to</a> <a id="3233" class="Datatype">RawTerm</a>
           <a id="3252" class="Symbol">;</a> <a id="3254" href="SMT.Script.Base.html#3186" class="InductiveConstructor">`var</a>            <a id="3270" class="Symbol">to</a> <a id="3273" class="InductiveConstructor">`varᵣ</a>
           <a id="3290" class="Symbol">;</a> <a id="3292" href="SMT.Script.Base.html#3236" class="InductiveConstructor">`lit</a>            <a id="3308" class="Symbol">to</a> <a id="3311" class="InductiveConstructor">`litᵣ</a>
           <a id="3328" class="Symbol">;</a> <a id="3330" href="SMT.Script.Base.html#3290" class="InductiveConstructor">`app</a>            <a id="3346" class="Symbol">to</a> <a id="3349" class="InductiveConstructor">`appᵣ</a>
           <a id="3366" class="Symbol">;</a> <a id="3368" href="SMT.Script.Base.html#3392" class="InductiveConstructor">`forall</a>         <a id="3384" class="Symbol">to</a> <a id="3387" class="InductiveConstructor">`forallᵣ</a>
           <a id="3407" class="Symbol">;</a> <a id="3409" href="SMT.Script.Base.html#3477" class="InductiveConstructor">`exists</a>         <a id="3425" class="Symbol">to</a> <a id="3428" class="InductiveConstructor">`existsᵣ</a>
           <a id="3448" class="Symbol">;</a> <a id="3450" href="SMT.Script.Base.html#3562" class="InductiveConstructor">`let</a>            <a id="3466" class="Symbol">to</a> <a id="3469" class="InductiveConstructor">`letᵣ</a>
           <a id="3486" class="Symbol">;</a> <a id="3488" href="SMT.Script.Base.html#3649" class="Function">Args</a>            <a id="3504" class="Symbol">to</a> <a id="3507" class="Function">RawArgs</a>
           <a id="3526" class="Symbol">;</a> <a id="3528" href="SMT.Script.Base.html#9244" class="InductiveConstructor">`set-logic</a>      <a id="3544" class="Symbol">to</a> <a id="3547" class="InductiveConstructor">`set-logicᵣ</a>
           <a id="3570" class="Symbol">;</a> <a id="3572" href="SMT.Script.Base.html#9307" class="InductiveConstructor">`declare-const</a>  <a id="3588" class="Symbol">to</a> <a id="3591" class="InductiveConstructor">`declare-constᵣ</a>
           <a id="3618" class="Symbol">;</a> <a id="3620" href="SMT.Script.Base.html#9388" class="InductiveConstructor">`assert</a>         <a id="3636" class="Symbol">to</a> <a id="3639" class="InductiveConstructor">`assertᵣ</a>
           <a id="3659" class="Symbol">;</a> <a id="3661" href="SMT.Script.Base.html#9451" class="InductiveConstructor">`check-sat</a>      <a id="3677" class="Symbol">to</a> <a id="3680" class="InductiveConstructor">`check-satᵣ</a>
           <a id="3703" class="Symbol">;</a> <a id="3705" href="SMT.Script.Base.html#9508" class="InductiveConstructor">`get-model</a>      <a id="3721" class="Symbol">to</a> <a id="3724" class="InductiveConstructor">`get-modelᵣ</a>
           <a id="3747" class="Symbol">;</a> <a id="3749" href="SMT.Script.Base.html#9148" class="Datatype">Script</a>          <a id="3765" class="Symbol">to</a> <a id="3768" class="Datatype">RawScript</a>
           <a id="3789" class="Symbol">;</a> <a id="3791" href="SMT.Script.Base.html#6492" class="InductiveConstructor">[]</a>              <a id="3807" class="Symbol">to</a> <a id="3810" class="InductiveConstructor">[]ᵣ</a>
           <a id="3825" class="Symbol">)</a>

<a id="3828" class="Keyword">open</a> <a id="3833" class="Keyword">import</a> <a id="3840" href="SMT.Script.Names.html" class="Module">SMT.Script.Names</a> <a id="3857" href="SMT.Theory.Raw.Base.html#2017" class="Function">rawTheory</a> <a id="3867" class="Keyword">using</a> <a id="3873" class="Symbol">(</a><a id="3874" href="SMT.Script.Names.html#3120" class="Function">x′es</a><a id="3878" class="Symbol">)</a>

<a id="showRawScript"></a><a id="3881" href="SMT.Theory.Raw.Base.html#3881" class="Function">showRawScript</a> <a id="3895" class="Symbol">:</a> <a id="3897" class="Symbol">{</a><a id="3898" href="SMT.Theory.Raw.Base.html#3898" class="Bound">Γᵣ</a> <a id="3901" class="Symbol">:</a> <a id="3903" href="SMT.Theory.Raw.Base.html#3156" class="Function">RawCtxt</a><a id="3910" class="Symbol">}</a> <a id="3912" class="Symbol">{</a><a id="3913" href="SMT.Theory.Raw.Base.html#3913" class="Bound">Ξᵣ</a> <a id="3916" class="Symbol">:</a> <a id="3918" href="SMT.Theory.Raw.Base.html#3110" class="Function">RawOutputCtxt</a><a id="3931" class="Symbol">}</a> <a id="3933" class="Symbol">→</a> <a id="3935" href="SMT.Theory.Raw.Base.html#3768" class="Datatype">RawScript</a> <a id="3945" class="InductiveConstructor">[]</a> <a id="3948" href="SMT.Theory.Raw.Base.html#3898" class="Bound">Γᵣ</a> <a id="3951" href="SMT.Theory.Raw.Base.html#3913" class="Bound">Ξᵣ</a> <a id="3954" class="Symbol">→</a> <a id="3956" href="Agda.Builtin.String.html#336" class="Postulate">String</a>
<a id="3963" href="SMT.Theory.Raw.Base.html#3881" class="Function">showRawScript</a> <a id="3977" href="SMT.Theory.Raw.Base.html#3977" class="Bound">scrᵣ</a> <a id="3982" class="Symbol">=</a> <a id="3984" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a> <a id="3990" class="Symbol">(</a><a id="3991" href="SMT.Theory.Class.Solvable.html#1875" class="Field">Solvable.toSMTLIBWithOutputParser</a> <a id="4025" href="SMT.Theory.Raw.Base.html#2776" class="Function">rawSolvable</a> <a id="4037" href="SMT.Theory.Raw.Base.html#3977" class="Bound">scrᵣ</a><a id="4041" class="Symbol">)</a>

<a id="4044" class="Comment">-- Define a raw variable, instead of re-exporting _∋_, since there is only a</a>
<a id="4121" class="Comment">-- single sort, so exposing the sort at the type-level is pointless.</a>
<a id="RawVar"></a><a id="4190" href="SMT.Theory.Raw.Base.html#4190" class="Function">RawVar</a> <a id="4197" class="Symbol">:</a> <a id="4199" href="SMT.Theory.Raw.Base.html#3156" class="Function">RawCtxt</a> <a id="4207" class="Symbol">→</a> <a id="4209" href="Agda.Primitive.html#326" class="Primitive">Set</a>
<a id="4213" href="SMT.Theory.Raw.Base.html#4190" class="Function">RawVar</a> <a id="4220" href="SMT.Theory.Raw.Base.html#4220" class="Bound">Γ</a> <a id="4222" class="Symbol">=</a> <a id="4224" href="SMT.Theory.Raw.Base.html#4220" class="Bound">Γ</a> <a id="4226" href="SMT.Theory.Raw.Base.html#3196" class="Function Operator">∋ᵣ</a> <a id="4229" href="SMT.Theory.Raw.Base.html#1650" class="InductiveConstructor">⋆</a>
</pre></body></html>
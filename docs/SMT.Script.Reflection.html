<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>SMT.Script.Reflection</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Symbol">{-#</a> <a id="5" class="Keyword">OPTIONS</a> <a id="13" class="Pragma">--guardedness</a> <a id="27" class="Symbol">#-}</a>

<a id="32" class="Comment">--------------------------------------------------------------------------------</a>
<a id="113" class="Comment">-- Schmitty the Solver</a>
<a id="136" class="Comment">--</a>
<a id="139" class="Comment">-- Defines `reflectToScript`, which uses an instance of the `Reflectable` class</a>
<a id="219" class="Comment">-- to convert reflected Agda syntax to an SMT-LIB script.</a>
<a id="277" class="Comment">--------------------------------------------------------------------------------</a>

<a id="359" class="Keyword">open</a> <a id="364" class="Keyword">import</a> <a id="371" href="SMT.Theory.html" class="Module">SMT.Theory</a>

<a id="383" class="Keyword">module</a> <a id="390" href="SMT.Script.Reflection.html" class="Module">SMT.Script.Reflection</a> <a id="412" class="Symbol">{</a><a id="413" href="SMT.Script.Reflection.html#413" class="Bound">theory</a> <a id="420" class="Symbol">:</a> <a id="422" href="SMT.Theory.Base.html#3890" class="Record">Theory</a><a id="428" class="Symbol">}</a> <a id="430" class="Symbol">(</a><a id="431" href="SMT.Script.Reflection.html#431" class="Bound">reflectable</a> <a id="443" class="Symbol">:</a> <a id="445" href="SMT.Theory.Reflectable.html#933" class="Record">Reflectable</a> <a id="457" href="SMT.Script.Reflection.html#413" class="Bound">theory</a><a id="463" class="Symbol">)</a> <a id="465" class="Keyword">where</a>

<a id="472" class="Keyword">open</a> <a id="477" href="SMT.Theory.Base.html#3890" class="Module">Theory</a> <a id="484" href="SMT.Script.Reflection.html#413" class="Bound">theory</a>
<a id="491" class="Keyword">open</a> <a id="496" href="SMT.Theory.Reflectable.html#933" class="Module">Reflectable</a> <a id="508" href="SMT.Script.Reflection.html#431" class="Bound">reflectable</a>

<a id="521" class="Keyword">open</a> <a id="526" class="Keyword">import</a> <a id="533" href="Category.Monad.html" class="Module">Category.Monad</a>
<a id="548" class="Keyword">open</a> <a id="553" class="Keyword">import</a> <a id="560" href="Data.Environment.html" class="Module">Data.Environment</a> <a id="577" class="Symbol">as</a> <a id="580" class="Module">Env</a> <a id="584" class="Keyword">using</a> <a id="590" class="Symbol">(</a><a id="591" href="Data.Environment.html#360" class="Datatype">Env</a><a id="594" class="Symbol">;</a> <a id="596" href="Data.Environment.html#427" class="InductiveConstructor Operator">_∷_</a><a id="599" class="Symbol">;</a> <a id="601" href="Data.Environment.html#410" class="InductiveConstructor">[]</a><a id="603" class="Symbol">)</a>
<a id="605" class="Keyword">open</a> <a id="610" class="Keyword">import</a> <a id="617" href="Data.Fin.html" class="Module">Data.Fin</a> <a id="626" class="Symbol">as</a> <a id="629" class="Module">Fin</a> <a id="633" class="Keyword">using</a> <a id="639" class="Symbol">(</a><a id="640" href="Data.Fin.Base.html#1126" class="Datatype">Fin</a><a id="643" class="Symbol">;</a> <a id="645" href="Data.Fin.Base.html#1179" class="InductiveConstructor">suc</a><a id="648" class="Symbol">;</a> <a id="650" href="Data.Fin.Base.html#1148" class="InductiveConstructor">zero</a><a id="654" class="Symbol">)</a>
<a id="656" class="Keyword">open</a> <a id="661" class="Keyword">import</a> <a id="668" href="Data.List.html" class="Module">Data.List</a> <a id="678" class="Symbol">as</a> <a id="681" class="Module">List</a> <a id="686" class="Keyword">using</a> <a id="692" class="Symbol">(</a><a id="693" href="Agda.Builtin.List.html#148" class="Datatype">List</a><a id="697" class="Symbol">;</a> <a id="699" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">_∷_</a><a id="702" class="Symbol">;</a> <a id="704" href="Data.List.Base.html#10383" class="InductiveConstructor">[]</a><a id="706" class="Symbol">;</a> <a id="708" href="Data.List.Base.html#1810" class="Function Operator">_++_</a><a id="712" class="Symbol">;</a> <a id="714" href="Data.List.Base.html#4864" class="Function">length</a><a id="720" class="Symbol">)</a>
<a id="722" class="Keyword">open</a> <a id="727" class="Keyword">import</a> <a id="734" href="Data.List.Relation.Unary.All.html" class="Module">Data.List.Relation.Unary.All</a> <a id="763" class="Keyword">using</a> <a id="769" class="Symbol">(</a><a id="770" href="Data.List.Relation.Unary.All.html#1444" class="Datatype">All</a><a id="773" class="Symbol">;</a> <a id="775" href="Data.List.Relation.Unary.All.html#1524" class="InductiveConstructor Operator">_∷_</a><a id="778" class="Symbol">;</a> <a id="780" href="Data.List.Relation.Unary.All.html#1507" class="InductiveConstructor">[]</a><a id="782" class="Symbol">)</a>
<a id="784" class="Keyword">open</a> <a id="789" class="Keyword">import</a> <a id="796" href="Data.List.Relation.Unary.Any.html" class="Module">Data.List.Relation.Unary.Any</a> <a id="825" class="Symbol">as</a> <a id="828" class="Module">Any</a> <a id="832" class="Keyword">using</a> <a id="838" class="Symbol">(</a><a id="839" href="Data.List.Relation.Unary.Any.html#1219" class="InductiveConstructor">here</a><a id="843" class="Symbol">;</a> <a id="845" href="Data.List.Relation.Unary.Any.html#1272" class="InductiveConstructor">there</a><a id="850" class="Symbol">)</a>
<a id="852" class="Keyword">open</a> <a id="857" class="Keyword">import</a> <a id="864" href="Data.Maybe.html" class="Module">Data.Maybe</a> <a id="875" class="Symbol">as</a> <a id="878" class="Module">Maybe</a> <a id="884" class="Keyword">using</a> <a id="890" class="Symbol">(</a><a id="891" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a><a id="896" class="Symbol">;</a> <a id="898" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a><a id="902" class="Symbol">;</a> <a id="904" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a><a id="911" class="Symbol">)</a>
<a id="913" class="Keyword">import</a> <a id="920" href="Data.Maybe.Categorical.html" class="Module">Data.Maybe.Categorical</a> <a id="943" class="Symbol">as</a> <a id="946" class="Module">MaybeCat</a>
<a id="955" class="Keyword">open</a> <a id="960" class="Keyword">import</a> <a id="967" href="Data.Nat.html" class="Module">Data.Nat</a> <a id="976" class="Symbol">as</a> <a id="979" class="Module">Nat</a> <a id="983" class="Keyword">using</a> <a id="989" class="Symbol">(</a><a id="990" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="991" class="Symbol">;</a> <a id="993" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="996" class="Symbol">;</a> <a id="998" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="1002" class="Symbol">)</a>
<a id="1004" class="Keyword">open</a> <a id="1009" class="Keyword">import</a> <a id="1016" href="Data.Product.html" class="Module">Data.Product</a> <a id="1029" class="Symbol">as</a> <a id="1032" class="Module">Prod</a> <a id="1037" class="Keyword">using</a> <a id="1043" class="Symbol">(</a><a id="1044" href="Data.Product.html#1369" class="Function">∃</a><a id="1045" class="Symbol">;</a> <a id="1047" href="Data.Product.html#1806" class="Function">∃-syntax</a><a id="1055" class="Symbol">;</a> <a id="1057" href="Data.Product.html#2247" class="Function Operator">-,_</a><a id="1060" class="Symbol">;</a> <a id="1062" href="Data.Product.html#1167" class="Function Operator">_×_</a><a id="1065" class="Symbol">;</a> <a id="1067" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a><a id="1070" class="Symbol">;</a> <a id="1072" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a><a id="1077" class="Symbol">;</a> <a id="1079" href="Agda.Builtin.Sigma.html#264" class="Field">proj₂</a><a id="1084" class="Symbol">)</a>
<a id="1086" class="Keyword">open</a> <a id="1091" class="Keyword">import</a> <a id="1098" href="Data.String.html" class="Module">Data.String</a> <a id="1110" class="Symbol">as</a> <a id="1113" class="Module">String</a> <a id="1120" class="Keyword">using</a> <a id="1126" class="Symbol">(</a><a id="1127" href="Agda.Builtin.String.html#336" class="Postulate">String</a><a id="1133" class="Symbol">)</a>
<a id="1135" class="Keyword">open</a> <a id="1140" class="Keyword">import</a> <a id="1147" href="Data.Unit.html" class="Module">Data.Unit</a> <a id="1157" class="Symbol">as</a> <a id="1160" class="Module">Unit</a> <a id="1165" class="Keyword">using</a> <a id="1171" class="Symbol">(</a><a id="1172" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a><a id="1173" class="Symbol">)</a>
<a id="1175" class="Keyword">open</a> <a id="1180" class="Keyword">import</a> <a id="1187" href="Data.Vec.html" class="Module">Data.Vec</a> <a id="1196" class="Symbol">as</a> <a id="1199" class="Module">Vec</a> <a id="1203" class="Keyword">using</a> <a id="1209" class="Symbol">(</a><a id="1210" href="Data.Vec.Base.html#998" class="Datatype">Vec</a><a id="1213" class="Symbol">;</a> <a id="1215" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">_∷_</a><a id="1218" class="Symbol">;</a> <a id="1220" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a><a id="1222" class="Symbol">)</a>
<a id="1224" class="Keyword">open</a> <a id="1229" class="Keyword">import</a> <a id="1236" href="Function.html" class="Module">Function</a> <a id="1245" class="Keyword">using</a> <a id="1251" class="Symbol">(</a><a id="1252" href="Function.Base.html#1919" class="Function Operator">_$_</a><a id="1255" class="Symbol">;</a> <a id="1257" href="Function.Base.html#4121" class="Function Operator">case_of_</a><a id="1265" class="Symbol">;</a> <a id="1267" href="Function.Base.html#1031" class="Function Operator">_∘_</a><a id="1270" class="Symbol">;</a> <a id="1272" href="Function.Base.html#636" class="Function">const</a><a id="1277" class="Symbol">;</a> <a id="1279" href="Function.Base.html#1554" class="Function">flip</a><a id="1283" class="Symbol">;</a> <a id="1285" href="Function.Base.html#615" class="Function">id</a><a id="1287" class="Symbol">)</a>
<a id="1289" class="Keyword">import</a> <a id="1296" href="Function.Identity.Categorical.html" class="Module">Function.Identity.Categorical</a> <a id="1326" class="Symbol">as</a> <a id="1329" class="Module">Identity</a>
<a id="1338" class="Keyword">import</a> <a id="1345" href="Level.html" class="Module">Level</a>
<a id="1351" class="Keyword">import</a> <a id="1358" href="Reflection.html" class="Module">Reflection</a> <a id="1369" class="Symbol">as</a> <a id="1372" class="Module">Rfl</a>
<a id="1376" class="Keyword">open</a> <a id="1381" class="Keyword">import</a> <a id="1388" href="Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="1405" class="Keyword">using</a> <a id="1411" class="Symbol">(</a><a id="1412" href="Relation.Nullary.html#1511" class="Record">Dec</a><a id="1415" class="Symbol">;</a> <a id="1417" href="Relation.Nullary.html#1648" class="InductiveConstructor">yes</a><a id="1420" class="Symbol">;</a> <a id="1422" href="Relation.Nullary.html#1685" class="InductiveConstructor">no</a><a id="1424" class="Symbol">)</a>
<a id="1426" class="Keyword">open</a> <a id="1431" class="Keyword">import</a> <a id="1438" href="Relation.Nullary.Decidable.html" class="Module">Relation.Nullary.Decidable</a> <a id="1465" class="Keyword">using</a> <a id="1471" class="Symbol">(</a><a id="1472" href="Relation.Nullary.Decidable.Core.html#1365" class="Function">True</a><a id="1476" class="Symbol">)</a>
<a id="1478" class="Keyword">open</a> <a id="1483" class="Keyword">import</a> <a id="1490" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="1528" class="Keyword">using</a> <a id="1534" class="Symbol">(</a><a id="1535" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="1538" class="Symbol">;</a> <a id="1540" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="1544" class="Symbol">;</a> <a id="1546" href="Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a><a id="1549" class="Symbol">)</a>
<a id="1551" class="Keyword">open</a> <a id="1556" class="Keyword">import</a> <a id="1563" href="SMT.Script.Base.html" class="Module">SMT.Script.Base</a> <a id="1579" href="SMT.Theory.Base.html#3922" class="Function">baseTheory</a>
<a id="1590" class="Keyword">open</a> <a id="1595" class="Keyword">import</a> <a id="1602" href="SMT.Script.Show.html" class="Module">SMT.Script.Show</a> <a id="1618" href="SMT.Script.Reflection.html#413" class="Bound">theory</a>

<a id="1626" class="Keyword">private</a>
  <a id="1636" class="Keyword">variable</a>
    <a id="1649" href="SMT.Script.Reflection.html#1649" class="Generalizable">σ</a> <a id="1651" href="SMT.Script.Reflection.html#1651" class="Generalizable">σ′</a>    <a id="1657" class="Symbol">:</a> <a id="1659" href="SMT.Theory.Base.html#2591" class="Function">Sort</a>
    <a id="1668" href="SMT.Script.Reflection.html#1668" class="Generalizable">Γ</a> <a id="1670" href="SMT.Script.Reflection.html#1670" class="Generalizable">Γ′</a> <a id="1673" href="SMT.Script.Reflection.html#1673" class="Generalizable">δΓ</a> <a id="1676" class="Symbol">:</a> <a id="1678" href="SMT.Script.Base.html#2516" class="Function">Ctxt</a>
    <a id="1687" href="SMT.Script.Reflection.html#1687" class="Generalizable">Δ</a> <a id="1689" href="SMT.Script.Reflection.html#1689" class="Generalizable">Δ′</a>    <a id="1695" class="Symbol">:</a> <a id="1697" href="SMT.Script.Base.html#2516" class="Function">Ctxt</a>
    <a id="1706" href="SMT.Script.Reflection.html#1706" class="Generalizable">Σ</a>       <a id="1714" class="Symbol">:</a> <a id="1716" href="SMT.Theory.Base.html#1984" class="Record">Signature</a> <a id="1726" href="SMT.Script.Reflection.html#1649" class="Generalizable">σ</a>
    <a id="1732" href="SMT.Script.Reflection.html#1732" class="Generalizable">Σ′</a>      <a id="1740" class="Symbol">:</a> <a id="1742" href="SMT.Theory.Base.html#1984" class="Record">Signature</a> <a id="1752" href="SMT.Script.Reflection.html#1651" class="Generalizable">σ′</a>
    <a id="1759" href="SMT.Script.Reflection.html#1759" class="Generalizable">ξ</a> <a id="1761" href="SMT.Script.Reflection.html#1761" class="Generalizable">ξ′</a>    <a id="1767" class="Symbol">:</a> <a id="1769" href="SMT.Script.Base.html#5651" class="Datatype">OutputType</a>
    <a id="1784" href="SMT.Script.Reflection.html#1784" class="Generalizable">Ξ</a> <a id="1786" href="SMT.Script.Reflection.html#1786" class="Generalizable">Ξ′</a> <a id="1789" href="SMT.Script.Reflection.html#1789" class="Generalizable">δΞ</a> <a id="1792" class="Symbol">:</a> <a id="1794" href="SMT.Script.Base.html#5745" class="Function">OutputCtxt</a>

<a id="1806" class="Comment">-- * Reflection hooks</a>

<a id="1829" class="Comment">-- TODO: The checkRawTerm and checkRawCommand functions should be rewritten to</a>
<a id="1908" class="Comment">--       infer their argument sort, as opposed to just trying all sorts.</a>
<a id="1981" class="Comment">--       Premature optimisation and all that, but the current approach is</a>
<a id="2055" class="Comment">--       exponential.</a>
<a id="2077" class="Keyword">module</a> <a id="2084" href="SMT.Script.Reflection.html#2084" class="Module">_</a> <a id="2086" class="Keyword">where</a>

  <a id="2095" class="Keyword">open</a> <a id="2100" class="Keyword">import</a> <a id="2107" href="SMT.Theory.Raw.Reflection.html" class="Module">SMT.Theory.Raw.Reflection</a>

  <a id="2136" class="Keyword">private</a>
    <a id="2148" href="SMT.Script.Reflection.html#2148" class="Function">monadPlusMaybe</a> <a id="2163" class="Symbol">=</a> <a id="2165" href="Data.Maybe.Categorical.html#1616" class="Function">MaybeCat.monadPlus</a> <a id="2184" class="Symbol">{</a><a id="2185" href="Agda.Primitive.html#764" class="Primitive">Level.zero</a><a id="2195" class="Symbol">}</a>

  <a id="2200" class="Keyword">open</a> <a id="2205" href="Category.Monad.html#1023" class="Module">RawMonadPlus</a> <a id="2218" href="SMT.Script.Reflection.html#2148" class="Function">monadPlusMaybe</a> <a id="2233" class="Keyword">renaming</a> <a id="2242" class="Symbol">(</a><a id="2243" href="Category.Applicative.Indexed.html#1034" class="Function Operator">_⊛_</a> <a id="2247" class="Symbol">to</a> <a id="2250" class="Function Operator">_&lt;*&gt;_</a><a id="2255" class="Symbol">)</a>


  <a id="2261" class="Keyword">private</a>
    <a id="2273" class="Keyword">variable</a>
      <a id="2288" href="SMT.Script.Reflection.html#2288" class="Generalizable">σᵣ</a>         <a id="2299" class="Symbol">:</a> <a id="2301" href="SMT.Theory.Raw.Base.html#1513" class="Datatype">RawSort</a>
      <a id="2315" href="SMT.Script.Reflection.html#2315" class="Generalizable">Γᵣ</a> <a id="2318" href="SMT.Script.Reflection.html#2318" class="Generalizable">Γᵣ′</a> <a id="2322" href="SMT.Script.Reflection.html#2322" class="Generalizable">δΓᵣ</a> <a id="2326" class="Symbol">:</a> <a id="2328" href="SMT.Theory.Raw.Base.html#3187" class="Function">RawCtxt</a>
      <a id="2342" href="SMT.Script.Reflection.html#2342" class="Generalizable">Ξᵣ</a> <a id="2345" href="SMT.Script.Reflection.html#2345" class="Generalizable">Ξᵣ′</a> <a id="2349" href="SMT.Script.Reflection.html#2349" class="Generalizable">δΞᵣ</a> <a id="2353" class="Symbol">:</a> <a id="2355" href="SMT.Theory.Raw.Base.html#3141" class="Function">RawOutputCtxt</a>
      <a id="2375" href="SMT.Script.Reflection.html#2375" class="Generalizable">Δᵣ</a> <a id="2378" href="SMT.Script.Reflection.html#2378" class="Generalizable">Δᵣ′</a>     <a id="2386" class="Symbol">:</a> <a id="2388" href="SMT.Theory.Raw.Base.html#3187" class="Function">RawCtxt</a>

  <a id="2399" href="SMT.Script.Reflection.html#2399" class="Function">checkRawSort</a> <a id="2412" class="Symbol">:</a> <a id="2414" href="SMT.Theory.Raw.Base.html#1513" class="Datatype">RawSort</a> <a id="2422" class="Symbol">→</a> <a id="2424" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="2430" href="SMT.Theory.Base.html#2591" class="Function">Sort</a>
  <a id="2437" href="SMT.Script.Reflection.html#2399" class="Function">checkRawSort</a> <a id="2450" href="SMT.Theory.Raw.Base.html#1535" class="InductiveConstructor">⋆</a>        <a id="2459" class="Symbol">=</a> <a id="2461" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="2466" href="SMT.Theory.Base.html#2664" class="Function">BOOL</a>
  <a id="2473" href="SMT.Script.Reflection.html#2399" class="Function">checkRawSort</a> <a id="2486" class="Symbol">(</a><a id="2487" href="SMT.Theory.Raw.Base.html#1552" class="InductiveConstructor">TERM</a> <a id="2492" href="SMT.Script.Reflection.html#2492" class="Bound">x</a><a id="2493" class="Symbol">)</a> <a id="2495" class="Symbol">=</a> <a id="2497" href="SMT.Theory.Reflectable.html#1001" class="Field">checkSort</a> <a id="2507" href="SMT.Script.Reflection.html#2492" class="Bound">x</a>

  <a id="2512" href="SMT.Script.Reflection.html#2512" class="Function">checkRawVar</a> <a id="2524" class="Symbol">:</a> <a id="2526" class="Symbol">(</a><a id="2527" href="SMT.Script.Reflection.html#2527" class="Bound">Γ</a> <a id="2529" class="Symbol">:</a> <a id="2531" href="SMT.Script.Base.html#2516" class="Function">Ctxt</a><a id="2535" class="Symbol">)</a> <a id="2537" class="Symbol">(</a><a id="2538" href="SMT.Script.Reflection.html#2538" class="Bound">σ</a> <a id="2540" class="Symbol">:</a> <a id="2542" href="SMT.Theory.Base.html#2591" class="Function">Sort</a><a id="2546" class="Symbol">)</a> <a id="2548" class="Symbol">(</a><a id="2549" href="SMT.Script.Reflection.html#2549" class="Bound">n</a> <a id="2551" class="Symbol">:</a> <a id="2553" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="2554" class="Symbol">)</a> <a id="2556" class="Symbol">→</a> <a id="2558" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="2564" class="Symbol">(</a><a id="2565" href="SMT.Script.Reflection.html#2527" class="Bound">Γ</a> <a id="2567" href="SMT.Script.Base.html#2739" class="Function Operator">∋</a> <a id="2569" href="SMT.Script.Reflection.html#2538" class="Bound">σ</a><a id="2570" class="Symbol">)</a>
  <a id="2574" href="SMT.Script.Reflection.html#2512" class="Function">checkRawVar</a> <a id="2586" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>       <a id="2595" href="SMT.Script.Reflection.html#2595" class="Bound">σ</a> <a id="2597" href="SMT.Script.Reflection.html#2597" class="Bound">n</a>       <a id="2605" class="Symbol">=</a> <a id="2607" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>
  <a id="2617" href="SMT.Script.Reflection.html#2512" class="Function">checkRawVar</a> <a id="2629" class="Symbol">(</a><a id="2630" href="SMT.Script.Reflection.html#2630" class="Bound">σ′</a> <a id="2633" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="2635" href="SMT.Script.Reflection.html#2635" class="Bound">Γ</a><a id="2636" class="Symbol">)</a> <a id="2638" href="SMT.Script.Reflection.html#2638" class="Bound">σ</a> <a id="2640" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="2648" class="Symbol">=</a> <a id="2650" class="Symbol">⦇</a> <a id="2652" class="Symbol">(</a><a id="2653" href="Data.List.Relation.Unary.Any.html#1219" class="InductiveConstructor">here</a> <a id="2658" href="Function.Base.html#1031" class="Function Operator">∘</a> <a id="2660" href="Relation.Binary.PropositionalEquality.Core.html#1684" class="Function">sym</a><a id="2663" class="Symbol">)</a> <a id="2665" class="Symbol">(</a><a id="2666" href="Data.Maybe.Base.html#1212" class="Function">Maybe.decToMaybe</a> <a id="2683" class="Symbol">(</a><a id="2684" href="SMT.Script.Reflection.html#2630" class="Bound">σ′</a> <a id="2687" href="SMT.Theory.Base.html#2615" class="Function Operator">≟-Sort</a> <a id="2694" href="SMT.Script.Reflection.html#2638" class="Bound">σ</a><a id="2695" class="Symbol">))</a> <a id="2698" class="Symbol">⦈</a>
  <a id="2702" href="SMT.Script.Reflection.html#2512" class="Function">checkRawVar</a> <a id="2714" class="Symbol">(</a><a id="2715" href="SMT.Script.Reflection.html#2715" class="Bound">σ′</a> <a id="2718" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="2720" href="SMT.Script.Reflection.html#2720" class="Bound">Γ</a><a id="2721" class="Symbol">)</a> <a id="2723" href="SMT.Script.Reflection.html#2723" class="Bound">σ</a> <a id="2725" class="Symbol">(</a><a id="2726" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2730" href="SMT.Script.Reflection.html#2730" class="Bound">n</a><a id="2731" class="Symbol">)</a> <a id="2733" class="Symbol">=</a> <a id="2735" class="Symbol">⦇</a> <a id="2737" href="SMT.Script.Base.html#2788" class="Function">extendVar</a> <a id="2747" class="Symbol">(</a><a id="2748" href="SMT.Script.Reflection.html#2512" class="Function">checkRawVar</a> <a id="2760" href="SMT.Script.Reflection.html#2720" class="Bound">Γ</a> <a id="2762" href="SMT.Script.Reflection.html#2723" class="Bound">σ</a> <a id="2764" href="SMT.Script.Reflection.html#2730" class="Bound">n</a><a id="2765" class="Symbol">)</a> <a id="2767" class="Symbol">⦈</a>

  <a id="2772" class="Keyword">mutual</a>
    <a id="2783" href="SMT.Script.Reflection.html#2783" class="Function">checkRawTerm</a> <a id="2796" class="Symbol">:</a> <a id="2798" class="Symbol">(</a><a id="2799" href="SMT.Script.Reflection.html#2799" class="Bound">Γ</a> <a id="2801" class="Symbol">:</a> <a id="2803" href="SMT.Script.Base.html#2516" class="Function">Ctxt</a><a id="2807" class="Symbol">)</a> <a id="2809" class="Symbol">(</a><a id="2810" href="SMT.Script.Reflection.html#2810" class="Bound">σ</a> <a id="2812" class="Symbol">:</a> <a id="2814" href="SMT.Theory.Base.html#2591" class="Function">Sort</a><a id="2818" class="Symbol">)</a> <a id="2820" class="Symbol">{</a><a id="2821" href="SMT.Script.Reflection.html#2821" class="Bound">σᵣ</a> <a id="2824" class="Symbol">:</a> <a id="2826" href="SMT.Theory.Raw.Base.html#1513" class="Datatype">RawSort</a><a id="2833" class="Symbol">}</a> <a id="2835" class="Symbol">→</a> <a id="2837" href="SMT.Theory.Raw.Base.html#3264" class="Datatype">RawTerm</a> <a id="2845" href="SMT.Script.Reflection.html#2315" class="Generalizable">Γᵣ</a> <a id="2848" href="SMT.Script.Reflection.html#2821" class="Bound">σᵣ</a> <a id="2851" class="Symbol">→</a> <a id="2853" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="2859" class="Symbol">(</a><a id="2860" href="SMT.Script.Base.html#3269" class="Datatype">Term</a> <a id="2865" href="SMT.Script.Reflection.html#2799" class="Bound">Γ</a> <a id="2867" href="SMT.Script.Reflection.html#2810" class="Bound">σ</a><a id="2868" class="Symbol">)</a>
    <a id="2874" href="SMT.Script.Reflection.html#2783" class="Function">checkRawTerm</a> <a id="2887" href="SMT.Script.Reflection.html#2887" class="Bound">Γ</a> <a id="2889" href="SMT.Script.Reflection.html#2889" class="Bound">σ</a> <a id="2891" class="Symbol">(</a><a id="2892" href="SMT.Theory.Raw.Base.html#3380" class="InductiveConstructor">`appᵣ</a> <a id="2898" class="Symbol">(</a><a id="2899" class="Keyword">quote</a> <a id="2905" href="SMT.Theory.Raw.Reflection.html#3321" class="Function">rawVar</a><a id="2911" class="Symbol">)</a> <a id="2913" class="Symbol">(</a><a id="2914" href="SMT.Theory.Raw.Base.html#3304" class="InductiveConstructor">`varᵣ</a> <a id="2920" href="SMT.Script.Reflection.html#2920" class="Bound">n</a> <a id="2922" href="Data.List.Relation.Unary.All.html#1524" class="InductiveConstructor Operator">∷</a> <a id="2924" href="Data.List.Relation.Unary.All.html#1507" class="InductiveConstructor">[]</a><a id="2926" class="Symbol">))</a> <a id="2929" class="Symbol">=</a> <a id="2931" class="Keyword">do</a>
      <a id="2940" href="SMT.Script.Reflection.html#2940" class="Bound">x</a> <a id="2942" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="2944" href="SMT.Script.Reflection.html#2512" class="Function">checkRawVar</a> <a id="2956" href="SMT.Script.Reflection.html#2887" class="Bound">Γ</a> <a id="2958" href="SMT.Script.Reflection.html#2889" class="Bound">σ</a> <a id="2960" class="Symbol">(</a><a id="2961" href="Data.Fin.Base.html#1252" class="Function">Fin.toℕ</a> <a id="2969" class="Symbol">(</a><a id="2970" href="Data.List.Relation.Unary.Any.html#1817" class="Function">Any.index</a> <a id="2980" href="SMT.Script.Reflection.html#2920" class="Bound">n</a><a id="2981" class="Symbol">))</a>
      <a id="2990" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="2997" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="2999" href="SMT.Script.Base.html#3314" class="InductiveConstructor">`var</a> <a id="3004" href="SMT.Script.Reflection.html#2940" class="Bound">x</a>
    <a id="3010" href="SMT.Script.Reflection.html#2783" class="Function">checkRawTerm</a> <a id="3023" href="SMT.Script.Reflection.html#3023" class="Bound">Γ</a> <a id="3025" href="SMT.Script.Reflection.html#3025" class="Bound">σ</a> <a id="3027" class="Symbol">(</a><a id="3028" href="SMT.Theory.Raw.Base.html#3304" class="InductiveConstructor">`varᵣ</a> <a id="3034" href="SMT.Script.Reflection.html#3034" class="Bound">n</a><a id="3035" class="Symbol">)</a> <a id="3037" class="Symbol">=</a> <a id="3039" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a> <a id="3047" class="Comment">-- should be no naked variables</a>
    <a id="3083" href="SMT.Script.Reflection.html#2783" class="Function">checkRawTerm</a> <a id="3096" href="SMT.Script.Reflection.html#3096" class="Bound">Γ</a> <a id="3098" href="SMT.Script.Reflection.html#3098" class="Bound">σ</a> <a id="3100" class="Symbol">(</a><a id="3101" href="SMT.Theory.Raw.Base.html#3342" class="InductiveConstructor">`litᵣ</a> <a id="3107" href="SMT.Script.Reflection.html#3107" class="Bound">l</a><a id="3108" class="Symbol">)</a> <a id="3110" class="Symbol">=</a> <a id="3112" class="Keyword">do</a>
      <a id="3121" href="SMT.Script.Reflection.html#3121" class="Bound">l</a> <a id="3123" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="3125" href="SMT.Theory.Reflectable.html#1045" class="Field">checkLiteral</a> <a id="3138" href="SMT.Script.Reflection.html#3098" class="Bound">σ</a> <a id="3140" href="SMT.Script.Reflection.html#3107" class="Bound">l</a>
      <a id="3148" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="3155" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="3157" href="SMT.Script.Base.html#3364" class="InductiveConstructor">`lit</a> <a id="3162" href="SMT.Script.Reflection.html#3121" class="Bound">l</a>
    <a id="3168" href="SMT.Script.Reflection.html#2783" class="CatchallClause Function">checkRawTerm</a><a id="3180" class="CatchallClause"> </a><a id="3181" href="SMT.Script.Reflection.html#3181" class="CatchallClause Bound">Γ</a><a id="3182" class="CatchallClause"> </a><a id="3183" href="SMT.Script.Reflection.html#3183" class="CatchallClause Bound">σ</a><a id="3184" class="CatchallClause"> </a><a id="3185" class="CatchallClause Symbol">(</a><a id="3186" href="SMT.Theory.Raw.Base.html#3380" class="CatchallClause InductiveConstructor">`appᵣ</a><a id="3191" class="CatchallClause"> </a><a id="3192" href="SMT.Script.Reflection.html#3192" class="CatchallClause Bound">f</a><a id="3193" class="CatchallClause"> </a><a id="3194" href="SMT.Script.Reflection.html#3194" class="CatchallClause Bound">args</a><a id="3198" class="CatchallClause Symbol">)</a> <a id="3200" class="Symbol">=</a> <a id="3202" class="Keyword">do</a>
      <a id="3211" class="Symbol">(</a><a id="3212" href="SMT.Script.Reflection.html#3212" class="Bound">Σ</a> <a id="3214" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3216" href="SMT.Script.Reflection.html#3216" class="Bound">f</a><a id="3217" class="Symbol">)</a> <a id="3219" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="3221" href="SMT.Theory.Reflectable.html#1112" class="Field">checkIdentifier</a> <a id="3237" href="SMT.Script.Reflection.html#3183" class="Bound">σ</a> <a id="3239" href="SMT.Script.Reflection.html#3192" class="Bound">f</a>
      <a id="3247" href="SMT.Script.Reflection.html#3247" class="Bound">args</a> <a id="3252" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="3254" href="SMT.Script.Reflection.html#3865" class="Function">checkRawArgs</a> <a id="3267" href="SMT.Script.Reflection.html#3181" class="Bound">Γ</a> <a id="3269" class="Symbol">(</a><a id="3270" href="SMT.Theory.Base.html#2042" class="Field">ArgSorts</a> <a id="3279" href="SMT.Script.Reflection.html#3212" class="Bound">Σ</a><a id="3280" class="Symbol">)</a> <a id="3282" href="SMT.Script.Reflection.html#3194" class="Bound">args</a>
      <a id="3293" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="3300" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="3302" href="SMT.Script.Reflection.html#3216" class="Bound">f</a> <a id="3304" href="SMT.Script.Reflection.html#3247" class="Bound">args</a>
    <a id="3313" href="SMT.Script.Reflection.html#2783" class="Function">checkRawTerm</a> <a id="3326" href="SMT.Script.Reflection.html#3326" class="Bound">Γ</a> <a id="3328" href="SMT.Script.Reflection.html#3328" class="Bound">σ</a> <a id="3330" class="Symbol">(</a><a id="3331" href="SMT.Theory.Raw.Base.html#3418" class="InductiveConstructor">`forallᵣ</a> <a id="3340" href="SMT.Script.Reflection.html#3340" class="Bound">n</a> <a id="3342" href="SMT.Script.Reflection.html#3342" class="Bound">σᵣ</a> <a id="3345" href="SMT.Script.Reflection.html#3345" class="Bound">x</a><a id="3346" class="Symbol">)</a> <a id="3348" class="Symbol">=</a> <a id="3350" class="Keyword">do</a>
      <a id="3359" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="3364" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="3366" href="Data.Maybe.Base.html#1212" class="Function">Maybe.decToMaybe</a> <a id="3383" class="Symbol">(</a><a id="3384" href="SMT.Script.Reflection.html#3328" class="Bound">σ</a> <a id="3386" href="SMT.Theory.Base.html#2615" class="Function Operator">≟-Sort</a> <a id="3393" href="SMT.Theory.Base.html#2664" class="Function">BOOL</a><a id="3397" class="Symbol">)</a>
      <a id="3405" href="SMT.Script.Reflection.html#3405" class="Bound">σ′</a>   <a id="3410" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="3412" href="SMT.Script.Reflection.html#2399" class="Function">checkRawSort</a> <a id="3425" href="SMT.Script.Reflection.html#3342" class="Bound">σᵣ</a>
      <a id="3434" href="SMT.Script.Reflection.html#3434" class="Bound">x</a>    <a id="3439" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="3441" href="SMT.Script.Reflection.html#2783" class="Function">checkRawTerm</a> <a id="3454" class="Symbol">(</a><a id="3455" href="SMT.Script.Reflection.html#3405" class="Bound">σ′</a> <a id="3458" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="3460" href="SMT.Script.Reflection.html#3326" class="Bound">Γ</a><a id="3461" class="Symbol">)</a> <a id="3463" href="SMT.Theory.Base.html#2664" class="Function">BOOL</a> <a id="3468" href="SMT.Script.Reflection.html#3345" class="Bound">x</a>
      <a id="3476" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="3483" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="3485" href="SMT.Script.Base.html#3520" class="InductiveConstructor">`forall</a> <a id="3493" href="SMT.Script.Reflection.html#3340" class="Bound">n</a> <a id="3495" href="SMT.Script.Reflection.html#3405" class="Bound">σ′</a> <a id="3498" href="SMT.Script.Reflection.html#3434" class="Bound">x</a>
    <a id="3504" href="SMT.Script.Reflection.html#2783" class="Function">checkRawTerm</a> <a id="3517" href="SMT.Script.Reflection.html#3517" class="Bound">Γ</a> <a id="3519" href="SMT.Script.Reflection.html#3519" class="Bound">σ</a> <a id="3521" class="Symbol">(</a><a id="3522" href="SMT.Theory.Raw.Base.html#3459" class="InductiveConstructor">`existsᵣ</a> <a id="3531" href="SMT.Script.Reflection.html#3531" class="Bound">n</a> <a id="3533" href="SMT.Script.Reflection.html#3533" class="Bound">σᵣ</a> <a id="3536" href="SMT.Script.Reflection.html#3536" class="Bound">x</a><a id="3537" class="Symbol">)</a> <a id="3539" class="Symbol">=</a> <a id="3541" class="Keyword">do</a>
      <a id="3550" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="3555" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="3557" href="Data.Maybe.Base.html#1212" class="Function">Maybe.decToMaybe</a> <a id="3574" class="Symbol">(</a><a id="3575" href="SMT.Script.Reflection.html#3519" class="Bound">σ</a> <a id="3577" href="SMT.Theory.Base.html#2615" class="Function Operator">≟-Sort</a> <a id="3584" href="SMT.Theory.Base.html#2664" class="Function">BOOL</a><a id="3588" class="Symbol">)</a>
      <a id="3596" href="SMT.Script.Reflection.html#3596" class="Bound">σ′</a>   <a id="3601" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="3603" href="SMT.Script.Reflection.html#2399" class="Function">checkRawSort</a> <a id="3616" href="SMT.Script.Reflection.html#3533" class="Bound">σᵣ</a>
      <a id="3625" href="SMT.Script.Reflection.html#3625" class="Bound">x</a>    <a id="3630" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="3632" href="SMT.Script.Reflection.html#2783" class="Function">checkRawTerm</a> <a id="3645" class="Symbol">(</a><a id="3646" href="SMT.Script.Reflection.html#3596" class="Bound">σ′</a> <a id="3649" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="3651" href="SMT.Script.Reflection.html#3517" class="Bound">Γ</a><a id="3652" class="Symbol">)</a> <a id="3654" href="SMT.Theory.Base.html#2664" class="Function">BOOL</a> <a id="3659" href="SMT.Script.Reflection.html#3536" class="Bound">x</a>
      <a id="3667" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="3674" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="3676" href="SMT.Script.Base.html#3605" class="InductiveConstructor">`exists</a> <a id="3684" href="SMT.Script.Reflection.html#3531" class="Bound">n</a> <a id="3686" href="SMT.Script.Reflection.html#3596" class="Bound">σ′</a> <a id="3689" href="SMT.Script.Reflection.html#3625" class="Bound">x</a>
    <a id="3695" href="SMT.Script.Reflection.html#2783" class="Function">checkRawTerm</a> <a id="3708" href="SMT.Script.Reflection.html#3708" class="Bound">Γ</a> <a id="3710" href="SMT.Script.Reflection.html#3710" class="Bound">σ</a> <a id="3712" class="Symbol">(</a><a id="3713" href="SMT.Theory.Raw.Base.html#3500" class="InductiveConstructor">`letᵣ</a> <a id="3719" href="SMT.Script.Reflection.html#3719" class="Bound">n</a> <a id="3721" href="SMT.Script.Reflection.html#3721" class="Bound">σᵣ</a> <a id="3724" href="SMT.Script.Reflection.html#3724" class="Bound">x</a> <a id="3726" href="SMT.Script.Reflection.html#3726" class="Bound">y</a><a id="3727" class="Symbol">)</a> <a id="3729" class="Symbol">=</a> <a id="3731" class="Keyword">do</a>
      <a id="3740" href="SMT.Script.Reflection.html#3740" class="Bound">σ′</a> <a id="3743" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="3745" href="SMT.Script.Reflection.html#2399" class="Function">checkRawSort</a> <a id="3758" href="SMT.Script.Reflection.html#3721" class="Bound">σᵣ</a>
      <a id="3767" href="SMT.Script.Reflection.html#3767" class="Bound">x</a>  <a id="3770" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="3772" href="SMT.Script.Reflection.html#2783" class="Function">checkRawTerm</a> <a id="3785" href="SMT.Script.Reflection.html#3708" class="Bound">Γ</a> <a id="3787" href="SMT.Script.Reflection.html#3740" class="Bound">σ′</a> <a id="3790" href="SMT.Script.Reflection.html#3724" class="Bound">x</a>
      <a id="3798" href="SMT.Script.Reflection.html#3798" class="Bound">y</a>  <a id="3801" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="3803" href="SMT.Script.Reflection.html#2783" class="Function">checkRawTerm</a> <a id="3816" class="Symbol">(</a><a id="3817" href="SMT.Script.Reflection.html#3740" class="Bound">σ′</a> <a id="3820" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="3822" href="SMT.Script.Reflection.html#3708" class="Bound">Γ</a><a id="3823" class="Symbol">)</a> <a id="3825" href="SMT.Script.Reflection.html#3710" class="Bound">σ</a> <a id="3827" href="SMT.Script.Reflection.html#3726" class="Bound">y</a>
      <a id="3835" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="3842" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="3844" class="Symbol">(</a><a id="3845" href="SMT.Script.Base.html#3690" class="InductiveConstructor">`let</a> <a id="3850" href="SMT.Script.Reflection.html#3719" class="Bound">n</a> <a id="3852" href="SMT.Script.Reflection.html#3740" class="Bound">σ′</a> <a id="3855" href="SMT.Script.Reflection.html#3767" class="Bound">x</a> <a id="3857" href="SMT.Script.Reflection.html#3798" class="Bound">y</a><a id="3858" class="Symbol">)</a>

    <a id="3865" href="SMT.Script.Reflection.html#3865" class="Function">checkRawArgs</a> <a id="3878" class="Symbol">:</a> <a id="3880" class="Symbol">(</a><a id="3881" href="SMT.Script.Reflection.html#3881" class="Bound">Γ</a> <a id="3883" href="SMT.Script.Reflection.html#3883" class="Bound">Δ</a> <a id="3885" class="Symbol">:</a> <a id="3887" href="SMT.Script.Base.html#2516" class="Function">Ctxt</a><a id="3891" class="Symbol">)</a> <a id="3893" class="Symbol">→</a> <a id="3895" href="SMT.Theory.Raw.Base.html#3538" class="Function">RawArgs</a> <a id="3903" href="SMT.Script.Reflection.html#2315" class="Generalizable">Γᵣ</a> <a id="3906" href="SMT.Script.Reflection.html#2375" class="Generalizable">Δᵣ</a> <a id="3909" class="Symbol">→</a> <a id="3911" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="3917" class="Symbol">(</a><a id="3918" href="SMT.Script.Base.html#3777" class="Function">Args</a> <a id="3923" href="SMT.Script.Reflection.html#3881" class="Bound">Γ</a> <a id="3925" href="SMT.Script.Reflection.html#3883" class="Bound">Δ</a><a id="3926" class="Symbol">)</a>
    <a id="3932" href="SMT.Script.Reflection.html#3865" class="Function">checkRawArgs</a> <a id="3945" href="SMT.Script.Reflection.html#3945" class="Bound">Γ</a> <a id="3947" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>      <a id="3955" href="Data.List.Relation.Unary.All.html#1507" class="InductiveConstructor">[]</a>           <a id="3968" class="Symbol">=</a> <a id="3970" class="Symbol">⦇</a> <a id="3972" href="Data.List.Relation.Unary.All.html#1507" class="InductiveConstructor">[]</a> <a id="3975" class="Symbol">⦈</a>
    <a id="3981" href="SMT.Script.Reflection.html#3865" class="Function">checkRawArgs</a> <a id="3994" href="SMT.Script.Reflection.html#3994" class="Bound">Γ</a> <a id="3996" class="Symbol">(</a><a id="3997" href="SMT.Script.Reflection.html#3997" class="Bound">σ</a> <a id="3999" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4001" href="SMT.Script.Reflection.html#4001" class="Bound">Δ</a><a id="4002" class="Symbol">)</a> <a id="4004" class="Symbol">(</a><a id="4005" href="SMT.Script.Reflection.html#4005" class="Bound">arg</a> <a id="4009" href="Data.List.Relation.Unary.All.html#1524" class="InductiveConstructor Operator">∷</a> <a id="4011" href="SMT.Script.Reflection.html#4011" class="Bound">args</a><a id="4015" class="Symbol">)</a> <a id="4017" class="Symbol">=</a> <a id="4019" class="Symbol">⦇</a> <a id="4021" class="Symbol">(</a><a id="4022" href="SMT.Script.Reflection.html#2783" class="Function">checkRawTerm</a> <a id="4035" href="SMT.Script.Reflection.html#3994" class="Bound">Γ</a> <a id="4037" href="SMT.Script.Reflection.html#3997" class="Bound">σ</a> <a id="4039" href="SMT.Script.Reflection.html#4005" class="Bound">arg</a><a id="4042" class="Symbol">)</a> <a id="4044" href="Data.List.Relation.Unary.All.html#1524" class="InductiveConstructor Operator">∷</a> <a id="4046" class="Symbol">(</a><a id="4047" href="SMT.Script.Reflection.html#3865" class="Function">checkRawArgs</a> <a id="4060" href="SMT.Script.Reflection.html#3994" class="Bound">Γ</a> <a id="4062" href="SMT.Script.Reflection.html#4001" class="Bound">Δ</a> <a id="4064" href="SMT.Script.Reflection.html#4011" class="Bound">args</a><a id="4068" class="Symbol">)</a> <a id="4070" class="Symbol">⦈</a>
    <a id="4076" href="SMT.Script.Reflection.html#3865" class="CatchallClause Function">checkRawArgs</a><a id="4088" class="CatchallClause"> </a><a id="4089" class="CatchallClause Symbol">_</a><a id="4090" class="CatchallClause"> </a><a id="4091" class="CatchallClause Symbol">_</a><a id="4092" class="CatchallClause">       </a><a id="4099" class="CatchallClause Symbol">_</a>            <a id="4112" class="Symbol">=</a> <a id="4114" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>

  <a id="4125" href="SMT.Script.Reflection.html#4125" class="Function Operator">Script[_↦_,_↦_,_↦_]</a> <a id="4145" class="Symbol">:</a>
    <a id="4151" class="Symbol">(</a><a id="4152" href="SMT.Script.Reflection.html#4152" class="Bound">Γᵣ</a>  <a id="4156" class="Symbol">:</a> <a id="4158" href="SMT.Theory.Raw.Base.html#3187" class="Function">RawCtxt</a><a id="4165" class="Symbol">)</a>       <a id="4173" class="Symbol">(</a><a id="4174" href="SMT.Script.Reflection.html#4174" class="Bound">Γ</a>  <a id="4177" class="Symbol">:</a> <a id="4179" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="4183" href="SMT.Theory.Base.html#2591" class="Function">Sort</a> <a id="4188" class="Symbol">(</a><a id="4189" href="Data.List.Base.html#4864" class="Function">length</a> <a id="4196" href="SMT.Script.Reflection.html#4152" class="Bound">Γᵣ</a><a id="4198" class="Symbol">))</a>
    <a id="4205" class="Symbol">(</a><a id="4206" href="SMT.Script.Reflection.html#4206" class="Bound">Γᵣ′</a> <a id="4210" class="Symbol">:</a> <a id="4212" href="SMT.Theory.Raw.Base.html#3187" class="Function">RawCtxt</a><a id="4219" class="Symbol">)</a>       <a id="4227" class="Symbol">(</a><a id="4228" href="SMT.Script.Reflection.html#4228" class="Bound">Γ′</a> <a id="4231" class="Symbol">:</a> <a id="4233" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="4237" href="SMT.Theory.Base.html#2591" class="Function">Sort</a> <a id="4242" class="Symbol">(</a><a id="4243" href="Data.List.Base.html#4864" class="Function">length</a> <a id="4250" href="SMT.Script.Reflection.html#4206" class="Bound">Γᵣ′</a><a id="4253" class="Symbol">))</a>
    <a id="4260" class="Symbol">(</a><a id="4261" href="SMT.Script.Reflection.html#4261" class="Bound">Ξᵣ</a>  <a id="4265" class="Symbol">:</a> <a id="4267" href="SMT.Theory.Raw.Base.html#3141" class="Function">RawOutputCtxt</a><a id="4280" class="Symbol">)</a> <a id="4282" class="Symbol">(</a><a id="4283" href="SMT.Script.Reflection.html#4283" class="Bound">Ξ</a>  <a id="4286" class="Symbol">:</a> <a id="4288" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="4292" href="SMT.Script.Base.html#5651" class="Datatype">OutputType</a> <a id="4303" class="Symbol">(</a><a id="4304" href="Data.List.Base.html#4864" class="Function">length</a> <a id="4311" href="SMT.Script.Reflection.html#4261" class="Bound">Ξᵣ</a><a id="4313" class="Symbol">))</a> <a id="4316" class="Symbol">→</a> <a id="4318" href="Agda.Primitive.html#326" class="Primitive">Set</a>
  <a id="4324" href="SMT.Script.Reflection.html#4125" class="Function Operator">Script[</a> <a id="4332" class="Symbol">_</a> <a id="4334" href="SMT.Script.Reflection.html#4125" class="Function Operator">↦</a> <a id="4336" href="SMT.Script.Reflection.html#4336" class="Bound">Γ</a> <a id="4338" href="SMT.Script.Reflection.html#4125" class="Function Operator">,</a> <a id="4340" class="Symbol">_</a> <a id="4342" href="SMT.Script.Reflection.html#4125" class="Function Operator">↦</a> <a id="4344" href="SMT.Script.Reflection.html#4344" class="Bound">Γ′</a> <a id="4347" href="SMT.Script.Reflection.html#4125" class="Function Operator">,</a> <a id="4349" class="Symbol">_</a> <a id="4351" href="SMT.Script.Reflection.html#4125" class="Function Operator">↦</a> <a id="4353" href="SMT.Script.Reflection.html#4353" class="Bound">Ξ</a> <a id="4355" href="SMT.Script.Reflection.html#4125" class="Function Operator">]</a> <a id="4357" class="Symbol">=</a> <a id="4359" href="SMT.Script.Base.html#9276" class="Datatype">Script</a> <a id="4366" class="Symbol">(</a><a id="4367" href="Data.Vec.Base.html#7438" class="Function">Vec.toList</a> <a id="4378" href="SMT.Script.Reflection.html#4336" class="Bound">Γ</a><a id="4379" class="Symbol">)</a> <a id="4381" class="Symbol">(</a><a id="4382" href="Data.Vec.Base.html#7438" class="Function">Vec.toList</a> <a id="4393" href="SMT.Script.Reflection.html#4344" class="Bound">Γ′</a><a id="4395" class="Symbol">)</a> <a id="4397" class="Symbol">(</a><a id="4398" href="Data.Vec.Base.html#7438" class="Function">Vec.toList</a> <a id="4409" href="SMT.Script.Reflection.html#4353" class="Bound">Ξ</a><a id="4410" class="Symbol">)</a>

  <a id="4415" href="SMT.Script.Reflection.html#4415" class="Function">checkRawScript</a> <a id="4430" class="Symbol">:</a> <a id="4432" class="Symbol">{</a><a id="4433" href="SMT.Script.Reflection.html#4433" class="Bound">Γᵣ</a> <a id="4436" href="SMT.Script.Reflection.html#4436" class="Bound">Γᵣ′</a> <a id="4440" class="Symbol">:</a> <a id="4442" href="SMT.Theory.Raw.Base.html#3187" class="Function">RawCtxt</a><a id="4449" class="Symbol">}</a> <a id="4451" class="Symbol">{</a><a id="4452" href="SMT.Script.Reflection.html#4452" class="Bound">Ξᵣ</a> <a id="4455" class="Symbol">:</a> <a id="4457" href="SMT.Theory.Raw.Base.html#3141" class="Function">RawOutputCtxt</a><a id="4470" class="Symbol">}</a>
    <a id="4476" class="Symbol">→</a> <a id="4478" class="Symbol">(</a><a id="4479" href="SMT.Script.Reflection.html#4479" class="Bound">Γ</a> <a id="4481" class="Symbol">:</a> <a id="4483" href="Data.Vec.Base.html#998" class="Datatype">Vec</a> <a id="4487" href="SMT.Theory.Base.html#2591" class="Function">Sort</a> <a id="4492" class="Symbol">(</a><a id="4493" href="Data.List.Base.html#4864" class="Function">length</a> <a id="4500" href="SMT.Script.Reflection.html#4433" class="Bound">Γᵣ</a><a id="4502" class="Symbol">))</a>
    <a id="4509" class="Symbol">→</a> <a id="4511" href="SMT.Theory.Raw.Base.html#3799" class="Datatype">RawScript</a> <a id="4521" href="SMT.Script.Reflection.html#4433" class="Bound">Γᵣ</a> <a id="4524" href="SMT.Script.Reflection.html#4436" class="Bound">Γᵣ′</a> <a id="4528" href="SMT.Script.Reflection.html#4452" class="Bound">Ξᵣ</a>
    <a id="4535" class="Symbol">→</a> <a id="4537" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="4543" class="Symbol">(</a><a id="4544" href="Data.Product.html#1806" class="Function">∃[</a> <a id="4547" href="SMT.Script.Reflection.html#4547" class="Bound">Γ′</a> <a id="4550" href="Data.Product.html#1806" class="Function">]</a> <a id="4552" href="Data.Product.html#1806" class="Function">∃[</a> <a id="4555" href="SMT.Script.Reflection.html#4555" class="Bound">Ξ</a> <a id="4557" href="Data.Product.html#1806" class="Function">]</a> <a id="4559" href="SMT.Script.Reflection.html#4125" class="Function Operator">Script[</a> <a id="4567" href="SMT.Script.Reflection.html#4433" class="Bound">Γᵣ</a> <a id="4570" href="SMT.Script.Reflection.html#4125" class="Function Operator">↦</a> <a id="4572" href="SMT.Script.Reflection.html#4479" class="Bound">Γ</a> <a id="4574" href="SMT.Script.Reflection.html#4125" class="Function Operator">,</a> <a id="4576" href="SMT.Script.Reflection.html#4436" class="Bound">Γᵣ′</a> <a id="4580" href="SMT.Script.Reflection.html#4125" class="Function Operator">↦</a> <a id="4582" href="SMT.Script.Reflection.html#4547" class="Bound">Γ′</a> <a id="4585" href="SMT.Script.Reflection.html#4125" class="Function Operator">,</a> <a id="4587" href="SMT.Script.Reflection.html#4452" class="Bound">Ξᵣ</a> <a id="4590" href="SMT.Script.Reflection.html#4125" class="Function Operator">↦</a> <a id="4592" href="SMT.Script.Reflection.html#4555" class="Bound">Ξ</a> <a id="4594" href="SMT.Script.Reflection.html#4125" class="Function Operator">]</a><a id="4595" class="Symbol">)</a>
  <a id="4599" href="SMT.Script.Reflection.html#4415" class="Function">checkRawScript</a> <a id="4614" class="Symbol">{</a><a id="4615" href="SMT.Script.Reflection.html#4615" class="Bound">Γᵣ</a><a id="4617" class="Symbol">}</a> <a id="4619" class="Symbol">{</a><a id="4620" class="DottedPattern Symbol">.</a><a id="4621" href="SMT.Script.Reflection.html#4615" class="DottedPattern Bound">Γᵣ</a><a id="4623" class="Symbol">}</a> <a id="4625" class="Symbol">{</a><a id="4626" class="DottedPattern Symbol">.</a><a id="4627" href="Agda.Builtin.List.html#185" class="DottedPattern InductiveConstructor">[]</a><a id="4629" class="Symbol">}</a> <a id="4631" href="SMT.Script.Reflection.html#4631" class="Bound">Γ</a> <a id="4633" href="SMT.Theory.Raw.Base.html#3841" class="InductiveConstructor">[]ᵣ</a> <a id="4637" class="Symbol">=</a>
    <a id="4643" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="4650" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="4652" href="SMT.Script.Reflection.html#4631" class="Bound">Γ</a> <a id="4654" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4656" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a> <a id="4659" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4661" href="SMT.Script.Base.html#9339" class="InductiveConstructor">[]</a>
  <a id="4666" href="SMT.Script.Reflection.html#4415" class="Function">checkRawScript</a> <a id="4681" href="SMT.Script.Reflection.html#4681" class="Bound">Γ</a> <a id="4683" class="Symbol">(</a><a id="4684" href="SMT.Theory.Raw.Base.html#3578" class="InductiveConstructor">`set-logicᵣ</a> <a id="4696" href="SMT.Script.Reflection.html#4696" class="Bound">l</a> <a id="4698" href="SMT.Script.Reflection.html#4698" class="Bound">scr</a><a id="4701" class="Symbol">)</a> <a id="4703" class="Symbol">=</a> <a id="4705" class="Keyword">do</a>
    <a id="4712" class="Symbol">(</a><a id="4713" href="SMT.Script.Reflection.html#4713" class="Bound">Γ′</a> <a id="4716" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4718" href="SMT.Script.Reflection.html#4718" class="Bound">Ξ</a> <a id="4720" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4722" href="SMT.Script.Reflection.html#4722" class="Bound">scr</a><a id="4725" class="Symbol">)</a> <a id="4727" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="4729" href="SMT.Script.Reflection.html#4415" class="Function">checkRawScript</a> <a id="4744" href="SMT.Script.Reflection.html#4681" class="Bound">Γ</a> <a id="4746" href="SMT.Script.Reflection.html#4698" class="Bound">scr</a>
    <a id="4754" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="4761" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="4763" href="SMT.Script.Reflection.html#4713" class="Bound">Γ′</a> <a id="4766" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4768" href="SMT.Script.Reflection.html#4718" class="Bound">Ξ</a> <a id="4770" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4772" class="Symbol">(</a><a id="4773" href="SMT.Script.Base.html#9372" class="InductiveConstructor">`set-logic</a> <a id="4784" href="SMT.Script.Reflection.html#4696" class="Bound">l</a> <a id="4786" href="SMT.Script.Reflection.html#4722" class="Bound">scr</a><a id="4789" class="Symbol">)</a>
  <a id="4793" href="SMT.Script.Reflection.html#4415" class="Function">checkRawScript</a> <a id="4808" href="SMT.Script.Reflection.html#4808" class="Bound">Γ</a> <a id="4810" class="Symbol">(</a><a id="4811" href="SMT.Theory.Raw.Base.html#3622" class="InductiveConstructor">`declare-constᵣ</a> <a id="4827" class="Symbol">_</a> <a id="4829" href="SMT.Theory.Raw.Base.html#1535" class="InductiveConstructor">⋆</a> <a id="4831" class="Symbol">_)</a> <a id="4834" class="Symbol">=</a> <a id="4836" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a> <a id="4844" class="Comment">-- we never declare constants of type ⋆</a>
  <a id="4886" href="SMT.Script.Reflection.html#4415" class="Function">checkRawScript</a> <a id="4901" href="SMT.Script.Reflection.html#4901" class="Bound">Γ</a> <a id="4903" class="Symbol">(</a><a id="4904" href="SMT.Theory.Raw.Base.html#3622" class="InductiveConstructor">`declare-constᵣ</a> <a id="4920" href="SMT.Script.Reflection.html#4920" class="Bound">n</a> <a id="4922" class="Symbol">(</a><a id="4923" href="SMT.Theory.Raw.Base.html#1552" class="InductiveConstructor">TERM</a> <a id="4928" href="SMT.Script.Reflection.html#4928" class="Bound">σᵣ</a><a id="4930" class="Symbol">)</a> <a id="4932" href="SMT.Script.Reflection.html#4932" class="Bound">scr</a><a id="4935" class="Symbol">)</a> <a id="4937" class="Symbol">=</a> <a id="4939" class="Keyword">do</a>
    <a id="4946" href="SMT.Script.Reflection.html#4946" class="Bound">σ</a> <a id="4948" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="4950" href="SMT.Theory.Reflectable.html#1001" class="Field">checkSort</a> <a id="4960" href="SMT.Script.Reflection.html#4928" class="Bound">σᵣ</a>
    <a id="4967" href="SMT.Script.Reflection.html#4967" class="Bound">Γ′</a> <a id="4970" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4972" href="SMT.Script.Reflection.html#4972" class="Bound">Ξ</a> <a id="4974" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4976" href="SMT.Script.Reflection.html#4976" class="Bound">scr</a> <a id="4980" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="4982" href="SMT.Script.Reflection.html#4415" class="Function">checkRawScript</a> <a id="4997" class="Symbol">(</a><a id="4998" href="SMT.Script.Reflection.html#4946" class="Bound">σ</a> <a id="5000" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="5002" href="SMT.Script.Reflection.html#4901" class="Bound">Γ</a><a id="5003" class="Symbol">)</a> <a id="5005" href="SMT.Script.Reflection.html#4932" class="Bound">scr</a>
    <a id="5013" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="5020" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="5022" href="SMT.Script.Reflection.html#4967" class="Bound">Γ′</a> <a id="5025" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5027" href="SMT.Script.Reflection.html#4972" class="Bound">Ξ</a> <a id="5029" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5031" class="Symbol">(</a><a id="5032" href="SMT.Script.Base.html#9435" class="InductiveConstructor">`declare-const</a> <a id="5047" href="SMT.Script.Reflection.html#4920" class="Bound">n</a> <a id="5049" href="SMT.Script.Reflection.html#4946" class="Bound">σ</a> <a id="5051" href="SMT.Script.Reflection.html#4976" class="Bound">scr</a><a id="5054" class="Symbol">)</a>
  <a id="5058" href="SMT.Script.Reflection.html#4415" class="Function">checkRawScript</a> <a id="5073" href="SMT.Script.Reflection.html#5073" class="Bound">Γ</a> <a id="5075" class="Symbol">(</a><a id="5076" href="SMT.Theory.Raw.Base.html#3670" class="InductiveConstructor">`assertᵣ</a> <a id="5085" href="SMT.Script.Reflection.html#5085" class="Bound">x</a> <a id="5087" href="SMT.Script.Reflection.html#5087" class="Bound">scr</a><a id="5090" class="Symbol">)</a> <a id="5092" class="Symbol">=</a> <a id="5094" class="Keyword">do</a>
    <a id="5101" href="SMT.Script.Reflection.html#5101" class="Bound">x</a> <a id="5103" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="5105" class="Symbol">(</a><a id="5106" href="SMT.Script.Reflection.html#2783" class="Function">checkRawTerm</a> <a id="5119" class="Symbol">(</a><a id="5120" href="Data.Vec.Base.html#7438" class="Function">Vec.toList</a> <a id="5131" href="SMT.Script.Reflection.html#5073" class="Bound">Γ</a><a id="5132" class="Symbol">)</a> <a id="5134" href="SMT.Theory.Base.html#2664" class="Function">BOOL</a> <a id="5139" href="SMT.Script.Reflection.html#5085" class="Bound">x</a><a id="5140" class="Symbol">)</a>
    <a id="5146" class="Symbol">(</a><a id="5147" href="SMT.Script.Reflection.html#5147" class="Bound">Γ′</a> <a id="5150" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5152" href="SMT.Script.Reflection.html#5152" class="Bound">Ξ</a> <a id="5154" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5156" href="SMT.Script.Reflection.html#5156" class="Bound">scr</a><a id="5159" class="Symbol">)</a> <a id="5161" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="5163" class="Symbol">(</a><a id="5164" href="SMT.Script.Reflection.html#4415" class="Function">checkRawScript</a> <a id="5179" href="SMT.Script.Reflection.html#5073" class="Bound">Γ</a> <a id="5181" href="SMT.Script.Reflection.html#5087" class="Bound">scr</a><a id="5184" class="Symbol">)</a>
    <a id="5190" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="5197" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="5199" href="SMT.Script.Reflection.html#5147" class="Bound">Γ′</a> <a id="5202" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5204" href="SMT.Script.Reflection.html#5152" class="Bound">Ξ</a> <a id="5206" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5208" class="Symbol">(</a><a id="5209" href="SMT.Script.Base.html#9516" class="InductiveConstructor">`assert</a> <a id="5217" href="SMT.Script.Reflection.html#5101" class="Bound">x</a> <a id="5219" href="SMT.Script.Reflection.html#5156" class="Bound">scr</a><a id="5222" class="Symbol">)</a>
  <a id="5226" href="SMT.Script.Reflection.html#4415" class="Function">checkRawScript</a> <a id="5241" href="SMT.Script.Reflection.html#5241" class="Bound">Γ</a> <a id="5243" class="Symbol">(</a><a id="5244" href="SMT.Theory.Raw.Base.html#3711" class="InductiveConstructor">`check-satᵣ</a> <a id="5256" href="SMT.Script.Reflection.html#5256" class="Bound">scr</a><a id="5259" class="Symbol">)</a> <a id="5261" class="Symbol">=</a> <a id="5263" class="Keyword">do</a>
    <a id="5270" class="Symbol">(</a><a id="5271" href="SMT.Script.Reflection.html#5271" class="Bound">Γ′</a> <a id="5274" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5276" href="SMT.Script.Reflection.html#5276" class="Bound">Ξ</a> <a id="5278" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5280" href="SMT.Script.Reflection.html#5280" class="Bound">scr</a><a id="5283" class="Symbol">)</a> <a id="5285" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="5287" href="SMT.Script.Reflection.html#4415" class="Function">checkRawScript</a> <a id="5302" href="SMT.Script.Reflection.html#5241" class="Bound">Γ</a> <a id="5304" href="SMT.Script.Reflection.html#5256" class="Bound">scr</a>
    <a id="5312" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="5319" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="5321" href="SMT.Script.Reflection.html#5271" class="Bound">Γ′</a> <a id="5324" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5326" href="SMT.Script.Base.html#5676" class="InductiveConstructor">SAT</a> <a id="5330" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="5332" href="SMT.Script.Reflection.html#5276" class="Bound">Ξ</a> <a id="5334" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5336" class="Symbol">(</a><a id="5337" href="SMT.Script.Base.html#9579" class="InductiveConstructor">`check-sat</a> <a id="5348" href="SMT.Script.Reflection.html#5280" class="Bound">scr</a><a id="5351" class="Symbol">)</a>
  <a id="5355" href="SMT.Script.Reflection.html#4415" class="Function">checkRawScript</a> <a id="5370" href="SMT.Script.Reflection.html#5370" class="Bound">Γ</a> <a id="5372" class="Symbol">(</a><a id="5373" href="SMT.Theory.Raw.Base.html#3755" class="InductiveConstructor">`get-modelᵣ</a> <a id="5385" href="SMT.Script.Reflection.html#5385" class="Bound">scr</a><a id="5388" class="Symbol">)</a> <a id="5390" class="Symbol">=</a> <a id="5392" class="Keyword">do</a>
    <a id="5399" class="Symbol">(</a><a id="5400" href="SMT.Script.Reflection.html#5400" class="Bound">Γ′</a> <a id="5403" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5405" href="SMT.Script.Reflection.html#5405" class="Bound">Ξ</a> <a id="5407" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5409" href="SMT.Script.Reflection.html#5409" class="Bound">scr</a><a id="5412" class="Symbol">)</a> <a id="5414" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="5416" href="SMT.Script.Reflection.html#4415" class="Function">checkRawScript</a> <a id="5431" href="SMT.Script.Reflection.html#5370" class="Bound">Γ</a> <a id="5433" href="SMT.Script.Reflection.html#5385" class="Bound">scr</a>
    <a id="5441" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="5448" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="5450" href="SMT.Script.Reflection.html#5400" class="Bound">Γ′</a> <a id="5453" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5455" href="SMT.Script.Base.html#5697" class="InductiveConstructor">MODEL</a> <a id="5461" class="Symbol">(</a><a id="5462" href="Data.Vec.Base.html#7438" class="Function">Vec.toList</a> <a id="5473" href="SMT.Script.Reflection.html#5370" class="Bound">Γ</a><a id="5474" class="Symbol">)</a> <a id="5476" href="Data.Vec.Base.html#1053" class="InductiveConstructor Operator">∷</a> <a id="5478" href="SMT.Script.Reflection.html#5405" class="Bound">Ξ</a> <a id="5480" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5482" class="Symbol">(</a><a id="5483" href="SMT.Script.Base.html#9636" class="InductiveConstructor">`get-model</a> <a id="5494" href="SMT.Script.Reflection.html#5409" class="Bound">scr</a><a id="5497" class="Symbol">)</a>

<a id="5500" class="Keyword">module</a> <a id="5507" href="SMT.Script.Reflection.html#5507" class="Module">_</a> <a id="5509" class="Keyword">where</a>

  <a id="5518" class="Keyword">open</a> <a id="5523" class="Keyword">import</a> <a id="5530" href="SMT.Theory.Raw.Reflection.html" class="Module">SMT.Theory.Raw.Reflection</a>
  <a id="5558" class="Keyword">import</a> <a id="5565" href="Reflection.TypeChecking.Monad.Categorical.html" class="Module">Reflection.TypeChecking.Monad.Categorical</a> <a id="5607" class="Symbol">as</a> <a id="5610" class="Module">TC</a>

  <a id="5616" class="Keyword">private</a>
    <a id="5628" class="Keyword">open</a> <a id="5633" class="Keyword">module</a> <a id="5640" href="SMT.Script.Reflection.html#5640" class="Module">TCMonad</a> <a id="5648" class="Symbol">{</a><a id="5649" href="SMT.Script.Reflection.html#5649" class="Bound">ℓ</a><a id="5650" class="Symbol">}</a> <a id="5652" class="Symbol">=</a> <a id="5654" href="Category.Monad.html#832" class="Module">Category.Monad.RawMonad</a> <a id="5678" class="Symbol">{</a><a id="5679" href="SMT.Script.Reflection.html#5649" class="Bound">ℓ</a><a id="5680" class="Symbol">}</a> <a id="5682" href="Reflection.TypeChecking.Monad.Categorical.html#1061" class="Function">TC.monad</a> <a id="5691" class="Keyword">renaming</a> <a id="5700" class="Symbol">(</a><a id="5701" href="Category.Applicative.Indexed.html#1034" class="Function Operator">_⊛_</a> <a id="5705" class="Symbol">to</a> <a id="5708" class="Function Operator">_&lt;*&gt;_</a><a id="5713" class="Symbol">)</a>

  <a id="5718" href="SMT.Script.Reflection.html#5718" class="Function">reflectToScript</a> <a id="5734" class="Symbol">:</a> <a id="5736" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Rfl.Term</a> <a id="5745" class="Symbol">→</a> <a id="5747" href="Agda.Builtin.Reflection.html#8218" class="Postulate">Rfl.TC</a> <a id="5754" class="Symbol">(</a><a id="5755" href="Data.Product.html#1806" class="Function">∃[</a> <a id="5758" href="SMT.Script.Reflection.html#5758" class="Bound">Γ</a> <a id="5760" href="Data.Product.html#1806" class="Function">]</a> <a id="5762" href="SMT.Script.Base.html#9276" class="Datatype">Script</a> <a id="5769" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="5772" href="SMT.Script.Reflection.html#5758" class="Bound">Γ</a> <a id="5774" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="5776" class="Symbol">)</a>
  <a id="5780" href="SMT.Script.Reflection.html#5718" class="Function">reflectToScript</a> <a id="5796" href="SMT.Script.Reflection.html#5796" class="Bound">t</a> <a id="5798" class="Symbol">=</a> <a id="5800" class="Keyword">do</a>
    <a id="5807" class="Symbol">(</a><a id="5808" href="SMT.Script.Reflection.html#5808" class="Bound">Γᵣ</a> <a id="5811" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5813" href="SMT.Script.Reflection.html#5813" class="Bound">scrᵣ</a><a id="5817" class="Symbol">)</a> <a id="5819" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="5821" href="SMT.Theory.Raw.Reflection.html#8383" class="Function">reflectToRawScript</a> <a id="5840" href="SMT.Script.Reflection.html#5796" class="Bound">t</a>
    <a id="5846" href="Function.Base.html#4121" class="Function Operator">case</a> <a id="5851" href="SMT.Script.Reflection.html#4415" class="Function">checkRawScript</a> <a id="5866" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a> <a id="5869" href="SMT.Script.Reflection.html#5813" class="Bound">scrᵣ</a> <a id="5874" href="Function.Base.html#4121" class="Function Operator">of</a> <a id="5877" class="Symbol">λ</a> <a id="5879" class="Keyword">where</a>
      <a id="5891" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a> <a id="5899" class="Symbol">→</a> <a id="5901" href="Reflection.TypeChecking.Format.html#2592" class="Function">Rfl.typeErrorFmt</a> <a id="5918" class="String">&quot;Ill-typed script:\n%s&quot;</a> <a id="5942" class="Symbol">(</a><a id="5943" href="SMT.Theory.Raw.Base.html#3974" class="Function">showRawScript</a> <a id="5957" href="SMT.Script.Reflection.html#5813" class="Bound">scrᵣ</a><a id="5961" class="Symbol">)</a>
      <a id="5969" class="Symbol">(</a><a id="5970" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="5975" class="Symbol">(</a><a id="5976" href="SMT.Script.Reflection.html#5976" class="Bound">Γ</a> <a id="5978" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5980" href="Data.Vec.Base.html#1034" class="InductiveConstructor">[]</a> <a id="5983" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="5985" href="SMT.Script.Reflection.html#5985" class="Bound">scr</a><a id="5988" class="Symbol">))</a> <a id="5991" class="Symbol">→</a> <a id="5993" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="6000" class="Symbol">(</a><a id="6001" href="Data.Vec.Base.html#7438" class="Function">Vec.toList</a> <a id="6012" href="SMT.Script.Reflection.html#5976" class="Bound">Γ</a> <a id="6014" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="6016" href="SMT.Script.Reflection.html#5985" class="Bound">scr</a><a id="6019" class="Symbol">)</a>
</pre></body></html>
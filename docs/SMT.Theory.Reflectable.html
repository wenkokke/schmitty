<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>SMT.Theory.Reflectable</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">--------------------------------------------------------------------------------</a>
<a id="82" class="Comment">-- Schmitty the Solver</a>
<a id="105" class="Comment">--</a>
<a id="108" class="Comment">-- Defines the `Reflectable` class, which is used to provide integration with</a>
<a id="186" class="Comment">-- Agda reflection. To implement the `Reflectable` class, you need to provide</a>
<a id="264" class="Comment">-- conversions from the raw theory to the intended theory.</a>
<a id="323" class="Comment">--</a>
<a id="326" class="Comment">-- Optionally, you may implement the `proofComputation` function, which is used</a>
<a id="406" class="Comment">-- to generate proof objects which compute on closed terms. For an example, see</a>
<a id="486" class="Comment">-- `SMT.Theories.Ints.Reflectable`.</a>
<a id="522" class="Comment">--------------------------------------------------------------------------------</a>

<a id="604" class="Keyword">open</a> <a id="609" class="Keyword">import</a> <a id="616" href="SMT.Theory.Base.html" class="Module">SMT.Theory.Base</a>

<a id="633" class="Keyword">module</a> <a id="640" href="SMT.Theory.Reflectable.html" class="Module">SMT.Theory.Reflectable</a> <a id="663" class="Symbol">(</a><a id="664" href="SMT.Theory.Reflectable.html#664" class="Bound">theory</a> <a id="671" class="Symbol">:</a> <a id="673" href="SMT.Theory.Base.html#3890" class="Record">Theory</a><a id="679" class="Symbol">)</a> <a id="681" class="Keyword">where</a>

<a id="688" class="Keyword">open</a> <a id="693" href="SMT.Theory.Base.html#3890" class="Module">Theory</a> <a id="700" href="SMT.Theory.Reflectable.html#664" class="Bound">theory</a>

<a id="708" class="Keyword">import</a> <a id="715" href="Level.html" class="Module">Level</a>
<a id="721" class="Keyword">open</a> <a id="726" class="Keyword">import</a> <a id="733" href="Data.List.html" class="Module">Data.List</a> <a id="743" class="Symbol">as</a> <a id="746" class="Module">List</a> <a id="751" class="Keyword">using</a> <a id="757" class="Symbol">(</a><a id="758" href="Agda.Builtin.List.html#148" class="Datatype">List</a><a id="762" class="Symbol">)</a>
<a id="764" class="Keyword">open</a> <a id="769" class="Keyword">import</a> <a id="776" href="Data.Maybe.html" class="Module">Data.Maybe</a> <a id="787" class="Symbol">as</a> <a id="790" class="Module">Maybe</a> <a id="796" class="Keyword">using</a> <a id="802" class="Symbol">(</a><a id="803" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a><a id="808" class="Symbol">)</a>
<a id="810" class="Keyword">open</a> <a id="815" class="Keyword">import</a> <a id="822" href="Data.Product.html" class="Module">Data.Product</a> <a id="835" class="Symbol">as</a> <a id="838" class="Module">Prod</a> <a id="843" class="Keyword">using</a> <a id="849" class="Symbol">(</a><a id="850" href="Data.Product.html#916" class="Function">Σ-syntax</a><a id="858" class="Symbol">)</a>
<a id="860" class="Keyword">import</a> <a id="867" href="Reflection.html" class="Module">Reflection</a> <a id="878" class="Symbol">as</a> <a id="881" class="Module">Rfl</a>
<a id="885" class="Keyword">open</a> <a id="890" class="Keyword">import</a> <a id="897" href="SMT.Script.Base.html" class="Module">SMT.Script.Base</a> <a id="913" href="SMT.Theory.Base.html#3922" class="Field">baseTheory</a>


<a id="926" class="Keyword">record</a> <a id="Reflectable"></a><a id="933" href="SMT.Theory.Reflectable.html#933" class="Record">Reflectable</a> <a id="945" class="Symbol">:</a> <a id="947" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="951" class="Keyword">where</a>
  <a id="959" class="Keyword">field</a>
    <a id="Reflectable.sorts"></a><a id="969" href="SMT.Theory.Reflectable.html#969" class="Field">sorts</a>           <a id="985" class="Symbol">:</a> <a id="987" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="992" href="SMT.Theory.Base.html#2591" class="Function">Sort</a>
    <a id="Reflectable.checkSort"></a><a id="1001" href="SMT.Theory.Reflectable.html#1001" class="Field">checkSort</a>       <a id="1017" class="Symbol">:</a> <a id="1019" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Rfl.Term</a> <a id="1028" class="Symbol">→</a> <a id="1030" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="1036" href="SMT.Theory.Base.html#2591" class="Function">Sort</a>
    <a id="Reflectable.checkLiteral"></a><a id="1045" href="SMT.Theory.Reflectable.html#1045" class="Field">checkLiteral</a>    <a id="1061" class="Symbol">:</a> <a id="1063" class="Symbol">(</a><a id="1064" href="SMT.Theory.Reflectable.html#1064" class="Bound">σ</a> <a id="1066" class="Symbol">:</a> <a id="1068" href="SMT.Theory.Base.html#2591" class="Function">Sort</a><a id="1072" class="Symbol">)</a> <a id="1074" class="Symbol">→</a> <a id="1076" href="Agda.Builtin.Reflection.html#4092" class="Datatype">Rfl.Literal</a> <a id="1088" class="Symbol">→</a> <a id="1090" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="1096" class="Symbol">(</a><a id="1097" href="SMT.Theory.Base.html#2689" class="Function">Literal</a> <a id="1105" href="SMT.Theory.Reflectable.html#1064" class="Bound">σ</a><a id="1106" class="Symbol">)</a>
    <a id="Reflectable.checkIdentifier"></a><a id="1112" href="SMT.Theory.Reflectable.html#1112" class="Field">checkIdentifier</a> <a id="1128" class="Symbol">:</a> <a id="1130" class="Symbol">(</a><a id="1131" href="SMT.Theory.Reflectable.html#1131" class="Bound">σ</a> <a id="1133" class="Symbol">:</a> <a id="1135" href="SMT.Theory.Base.html#2591" class="Function">Sort</a><a id="1139" class="Symbol">)</a> <a id="1141" class="Symbol">→</a> <a id="1143" href="Agda.Builtin.Reflection.html#489" class="Postulate">Rfl.Name</a> <a id="1152" class="Symbol">→</a> <a id="1154" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="1160" class="Symbol">(</a><a id="1161" href="Data.Product.html#916" class="Function">Σ[</a> <a id="1164" href="SMT.Theory.Reflectable.html#1164" class="Bound">Σ</a> <a id="1166" href="Data.Product.html#916" class="Function">∈</a> <a id="1168" href="SMT.Theory.Base.html#1984" class="Record">Signature</a> <a id="1178" href="SMT.Theory.Reflectable.html#1131" class="Bound">σ</a> <a id="1180" href="Data.Product.html#916" class="Function">]</a> <a id="1182" href="SMT.Script.Base.html#3840" class="Function">Macro</a> <a id="1188" href="SMT.Theory.Reflectable.html#1164" class="Bound">Σ</a><a id="1189" class="Symbol">)</a>

    <a id="1196" class="Comment">-- |Return the name of a function `f : ∀ {..} → Goal → Goal` which will be called</a>
    <a id="1282" class="Comment">--  with `because &quot;solver&quot; Goal` as the argument. Can be used to produce proof objects</a>
    <a id="1373" class="Comment">--  that compute on closed terms.</a>
    <a id="Reflectable.proofComputation"></a><a id="1411" href="SMT.Theory.Reflectable.html#1411" class="Field">proofComputation</a> <a id="1428" class="Symbol">:</a> <a id="1430" class="Symbol">∀</a> <a id="1432" class="Symbol">{</a><a id="1433" href="SMT.Theory.Reflectable.html#1433" class="Bound">Γ</a><a id="1434" class="Symbol">}</a> <a id="1436" class="Symbol">→</a> <a id="1438" href="SMT.Script.Base.html#3269" class="Datatype">Term</a> <a id="1443" href="SMT.Theory.Reflectable.html#1433" class="Bound">Γ</a> <a id="1445" href="SMT.Theory.Base.html#2664" class="Function">BOOL</a> <a id="1450" class="Symbol">→</a> <a id="1452" href="Agda.Builtin.Reflection.html#489" class="Postulate">Rfl.Name</a>
</pre></body></html>